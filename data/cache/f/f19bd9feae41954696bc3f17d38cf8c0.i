a:2487:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"PL/SQL Tutorial";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Originaal asub ";}i:2;i:33;}i:5;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:45:"http://www.tutorialspoint.com/plsql/index.htm";i:1;s:4:"siin";}i:2;i:48;}i:6;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:". ";}i:2;i:102;}i:7;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:104;}i:8;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:104;}i:9;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:184:"PL/SQL is a combination of SQL along with the procedural features of programming languages. It was developed by Oracle Corporation in the early 90's to enhance the capabilities of SQL.";}i:2;i:107;}i:10;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:291;}i:11;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:291;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"PL/SQL is one of three key programming languages embedded in the Oracle Database, along with SQL itself and Java.";}i:2;i:293;}i:13;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:406;}i:14;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:406;}i:15;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"This tutorial will give you great understanding on PL/SQL to proceed with Oracle database and other advanced RDBMS concepts.";}i:2;i:408;}i:16;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:532;}i:17;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:534;}i:18;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:8:"Audience";i:1;i:3;i:2;i:534;}i:2;i:534;}i:19;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:534;}i:20;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:534;}i:21;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:358:"This tutorial is designed for Software Professionals, who are willing to learn PL/SQL Programming Language in simple and easy steps. This tutorial will give you great understanding on PL/SQL Programming concepts, and after completing this tutorial, you will be at intermediate level of expertise from where you can take yourself to higher level of expertise.";}i:2;i:554;}i:22;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:912;}i:23;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:914;}i:24;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"Prerequisites";i:1;i:3;i:2;i:914;}i:2;i:914;}i:25;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:914;}i:26;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:914;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:310:"Before proceeding with this tutorial, you should have a basic understanding of software basic concepts like what is database, source code, text editor and execution of programs, etc. If you already have understanding on SQL and other computer programming language then it will be an added advantage to proceed.";}i:2;i:939;}i:28;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1249;}i:29;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1252;}i:30;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"PL/SQL - Overview";i:1;i:2;i:2;i:1252;}i:2;i:1252;}i:31;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1252;}i:32;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1252;}i:33;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:204:"The PL/SQL programming language was developed by Oracle Corporation in the late 1980s as procedural extension language for SQL and the Oracle relational database. Following are notable facts about PL/SQL:";}i:2;i:1283;}i:34;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1488;}i:35;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:1488;}i:36;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1488;}i:37;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1488;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:" SQL is a completely portable, high-performance transaction-processing language.";}i:2;i:1492;}i:39;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1572;}i:40;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1572;}i:41;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1572;}i:42;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1572;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:" PL/SQL provides a built-in interpreted and ";}i:2;i:1576;}i:44;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"OS";}i:2;i:1620;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" independent programming environment.";}i:2;i:1622;}i:46;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1659;}i:47;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1659;}i:48;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1659;}i:49;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1659;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:77:" PL/SQL can also directly be called from the command-line SQL*Plus interface.";}i:2;i:1663;}i:51;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1740;}i:52;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1740;}i:53;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1740;}i:54;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1740;}i:55;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:" Direct call can also be made from external programming language calls to database.";}i:2;i:1744;}i:56;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1827;}i:57;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1827;}i:58;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1827;}i:59;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1827;}i:60;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:" PL/SQL's general syntax is based on that of ADA and Pascal programming language.";}i:2;i:1831;}i:61;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1912;}i:62;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1912;}i:63;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:1912;}i:64;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:1912;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:" Apart from Oracle, PL/SQL is available in TimesTen in-memory database and IBM DB2.";}i:2;i:1916;}i:66;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:1999;}i:67;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:1999;}i:68;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:1999;}i:69;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2001;}i:70;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"Features of PL/SQL";i:1;i:3;i:2;i:2001;}i:2;i:2001;}i:71;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2001;}i:72;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2001;}i:73;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"PL/SQL has the following features:";}i:2;i:2031;}i:74;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2066;}i:75;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:2066;}i:76;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2066;}i:77;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2066;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:" PL/SQL is tightly integrated with SQL.";}i:2;i:2070;}i:79;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2109;}i:80;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2109;}i:81;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2109;}i:82;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2109;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:" It offers extensive error checking.";}i:2;i:2113;}i:84;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2149;}i:85;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2149;}i:86;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2149;}i:87;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2149;}i:88;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" It offers numerous data types.";}i:2;i:2153;}i:89;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2184;}i:90;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2184;}i:91;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2184;}i:92;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2184;}i:93;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:" It offers a variety of programming structures.";}i:2;i:2188;}i:94;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2235;}i:95;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2235;}i:96;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2235;}i:97;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2235;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" It supports structured programming through functions and procedures.";}i:2;i:2239;}i:99;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2308;}i:100;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2308;}i:101;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2308;}i:102;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2308;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:" It supports object-oriented programming.";}i:2;i:2312;}i:104;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2353;}i:105;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2353;}i:106;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2353;}i:107;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2353;}i:108;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:" It supports developing web applications and server pages.";}i:2;i:2357;}i:109;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2415;}i:110;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2415;}i:111;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:2415;}i:112;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2419;}i:113;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Advantages of PL/SQL";i:1;i:3;i:2;i:2419;}i:2;i:2419;}i:114;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2419;}i:115;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2419;}i:116;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"PL/SQL has the following advantages:";}i:2;i:2451;}i:117;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2487;}i:118;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:2487;}i:119;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2487;}i:120;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2487;}i:121;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:274:" SQL is the standard database language and PL/SQL is strongly integrated with SQL. PL/SQL supports both static and dynamic SQL. Static SQL supports DML operations and transaction control from PL/SQL block. Dynamic SQL is SQL allows embedding DDL statements in PL/SQL blocks.";}i:2;i:2491;}i:122;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2765;}i:123;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2765;}i:124;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2765;}i:125;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2765;}i:126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:" PL/SQL allows sending an entire block of statements to the database at one time. This reduces network traffic and provides high performance for the applications.";}i:2;i:2769;}i:127;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2931;}i:128;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2931;}i:129;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2931;}i:130;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2931;}i:131;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:105:" PL/SQL gives high productivity to programmers as it can query, transform, and update data in a database.";}i:2;i:2935;}i:132;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3040;}i:133;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3040;}i:134;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3040;}i:135;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3040;}i:136;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:150:" PL/SQL saves time on design and debugging by strong features, such as exception handling, encapsulation, data hiding, and object-oriented data types.";}i:2;i:3044;}i:137;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3194;}i:138;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3194;}i:139;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3194;}i:140;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3194;}i:141;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:" Applications written in PL/SQL are fully portable.";}i:2;i:3198;}i:142;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3249;}i:143;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3249;}i:144;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3249;}i:145;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3249;}i:146;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:" PL/SQL provides high security level.";}i:2;i:3253;}i:147;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3290;}i:148;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3290;}i:149;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3290;}i:150;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3290;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:" PL/SQL provides access to predefined SQL packages.";}i:2;i:3294;}i:152;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3345;}i:153;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3345;}i:154;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3345;}i:155;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3345;}i:156;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:" PL/SQL provides support for Object-Oriented Programming.";}i:2;i:3349;}i:157;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3406;}i:158;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3406;}i:159;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3406;}i:160;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3406;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:" PL/SQL provides support for Developing Web Applications and Server Pages.";}i:2;i:3410;}i:162;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3484;}i:163;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3484;}i:164;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:3484;}i:165;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3485;}i:166;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"PL/SQL - Basic Syntax";i:1;i:2;i:2;i:3485;}i:2;i:3485;}i:167;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3485;}i:168;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3485;}i:169;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"PL/SQL is a block-structured language, meaning that PL/SQL programs are divided and written in logical blocks of code. Each block consists of three sub-parts:";}i:2;i:3520;}i:170;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3679;}i:171;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:3679;}i:172;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3679;}i:173;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3679;}i:174;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:3683;}i:175;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3684;}i:176;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"Declarations";}i:2;i:3686;}i:177;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3698;}i:178;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:" - This section starts with the keyword ";}i:2;i:3700;}i:179;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3740;}i:180;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"DECLARE";}i:2;i:3742;}i:181;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3749;}i:182;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:122:". It is an optional section and defines all variables, cursors, subprograms, and other elements to be used in the program.";}i:2;i:3751;}i:183;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:3873;}i:184;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:3873;}i:185;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3873;}i:186;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3873;}i:187;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:3877;}i:188;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3878;}i:189;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"Executable Commands";}i:2;i:3880;}i:190;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3899;}i:191;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:" - This section is enclosed between the keywords ";}i:2;i:3901;}i:192;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3950;}i:193;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"BEGIN";}i:2;i:3952;}i:194;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3957;}i:195;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:3959;}i:196;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3964;}i:197;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"END";}i:2;i:3966;}i:198;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3969;}i:199;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:226:" and it is a mandatory section. It consists of the executable PL/SQL statements of the program. It should have at least one executable line of code, which may be just a NULL command to indicate that nothing should be executed.";}i:2;i:3971;}i:200;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4197;}i:201;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4197;}i:202;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4197;}i:203;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4197;}i:204;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:4201;}i:205;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4202;}i:206;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"Exception handling";}i:2;i:4204;}i:207;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4222;}i:208;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:" - This section starts with the keyword ";}i:2;i:4224;}i:209;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4264;}i:210;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"EXCEPTION";}i:2;i:4266;}i:211;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4275;}i:212;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:". This section is again optional and contains exception(s) that handle errors in the program.";}i:2;i:4277;}i:213;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4370;}i:214;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4370;}i:215;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:4370;}i:216;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4370;}i:217;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:"Every PL/SQL statement ends with a semicolon ";}i:2;i:4372;}i:218;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4417;}i:219;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"(;)";}i:2;i:4419;}i:220;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4422;}i:221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:". PL/SQL blocks can be nested within other PL/SQL blocks using ";}i:2;i:4424;}i:222;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4487;}i:223;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"BEGIN";}i:2;i:4489;}i:224;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4494;}i:225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:4496;}i:226;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4501;}i:227;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"END";}i:2;i:4503;}i:228;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4506;}i:229;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:". Here is the basic structure of a PL/SQL block:";}i:2;i:4508;}i:230;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4557;}i:231;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:105:"DECLARE
   <declarations section>
BEGIN
   <executable command(s)>
EXCEPTION
   <exception handling>
END;";}i:2;i:4557;}i:232;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4679;}i:233;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"The "Hello World!" example:";i:1;i:3;i:2;i:4679;}i:2;i:4679;}i:234;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4679;}i:235;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:99:"DECLARE
   message  varchar2(20):= 'Hello, World!';
BEGIN
   dbms_output.put_line(message);
END;
\
";}i:2;i:4717;}i:236;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4717;}i:237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:4832;}i:238;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:4836;}i:239;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"end;";}i:2;i:4838;}i:240;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:4842;}i:241;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:" line signals the end of the PL/SQL block. To run the code from SQL command line, you may need to type / at the beginning of the first blank line after the last line of the code. When the above code is executed at SQL prompt, it produces the following result:  ";}i:2;i:4844;}i:242;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5106;}i:243;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:11:"Hello World";}i:2;i:5106;}i:244;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:40:"PL/SQL procedure successfully completed.";}i:2;i:5121;}i:245;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5167;}i:246;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"The PL/SQL Identifiers";i:1;i:3;i:2;i:5167;}i:2;i:5167;}i:247;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5167;}i:248;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5167;}i:249;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:261:"PL/SQL identifiers are constants, variables, exceptions, procedures, cursors, and reserved words. The identifiers consist of a letter optionally followed by more letters, numerals, dollar signs, underscores, and number signs and should not exceed 30 characters.";}i:2;i:5201;}i:250;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5462;}i:251;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5462;}i:252;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:"By default, identifiers are not case-sensitive. So you can use ";}i:2;i:5464;}i:253;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:5527;}i:254;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"integer";}i:2;i:5529;}i:255;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:5536;}i:256;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" or ";}i:2;i:5538;}i:257;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:5542;}i:258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"INTEGER";}i:2;i:5544;}i:259;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:5551;}i:260;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:" to represent a numeric value. You cannot use a reserved keyword as an identifier.";}i:2;i:5553;}i:261;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5635;}i:262;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5637;}i:263;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"The PL/SQL Delimiters";i:1;i:3;i:2;i:5637;}i:2;i:5637;}i:264;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5637;}i:265;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5637;}i:266;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:94:"A delimiter is a symbol with a special meaning. Following is the list of delimiters in PL/SQL:";}i:2;i:5670;}i:267;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5765;}i:268;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:22;i:2;i:5766;}i:2;i:5765;}i:269;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:5765;}i:270;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:5765;}i:271;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5765;}i:272;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" Delimiter      ";}i:2;i:5767;}i:273;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:5783;}i:274;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5783;}i:275;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Description       ";}i:2;i:5784;}i:276;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:5803;}i:277;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:5805;}i:278;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:5805;}i:279;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:5805;}i:280;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5805;}i:281;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" +, -, *, /    ";}i:2;i:5807;}i:282;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5822;}i:283;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5822;}i:284;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:" Addition, subtraction/negation, multiplication, division  ";}i:2;i:5823;}i:285;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5882;}i:286;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:5884;}i:287;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:5884;}i:288;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5884;}i:289;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" %  ";}i:2;i:5886;}i:290;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5890;}i:291;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5890;}i:292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Attribute indicator  ";}i:2;i:5891;}i:293;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5913;}i:294;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:5914;}i:295;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:5914;}i:296;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5914;}i:297;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" '  ";}i:2;i:5916;}i:298;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5920;}i:299;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:5920;}i:300;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:" Character string delimiter ";}i:2;i:5921;}i:301;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5949;}i:302;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:5950;}i:303;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:5950;}i:304;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5950;}i:305;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" .  ";}i:2;i:5952;}i:306;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5956;}i:307;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5956;}i:308;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Component selector  ";}i:2;i:5957;}i:309;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5978;}i:310;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:5979;}i:311;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:5979;}i:312;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5979;}i:313;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" (,)  ";}i:2;i:5981;}i:314;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:5987;}i:315;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:5987;}i:316;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Expression or list delimiter  ";}i:2;i:5988;}i:317;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6019;}i:318;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6020;}i:319;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6020;}i:320;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6020;}i:321;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" :  ";}i:2;i:6022;}i:322;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6026;}i:323;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6026;}i:324;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" Host variable indicator  ";}i:2;i:6027;}i:325;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6053;}i:326;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6054;}i:327;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6054;}i:328;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6054;}i:329;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" ,  ";}i:2;i:6056;}i:330;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6060;}i:331;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6060;}i:332;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" Item sepparator  ";}i:2;i:6061;}i:333;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6079;}i:334;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6080;}i:335;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6080;}i:336;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6080;}i:337;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6082;}i:338;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:6083;}i:339;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:6084;}i:340;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6086;}i:341;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6086;}i:342;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Quoted 	identifier delimiter  ";}i:2;i:6087;}i:343;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6118;}i:344;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6119;}i:345;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6119;}i:346;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6119;}i:347;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" =  ";}i:2;i:6121;}i:348;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6125;}i:349;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6125;}i:350;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Relational operator  ";}i:2;i:6126;}i:351;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6148;}i:352;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6149;}i:353;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6149;}i:354;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6149;}i:355;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" @  ";}i:2;i:6151;}i:356;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6155;}i:357;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6155;}i:358;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" Remote access indicator  ";}i:2;i:6156;}i:359;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6182;}i:360;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6183;}i:361;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6183;}i:362;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6183;}i:363;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" ;  ";}i:2;i:6185;}i:364;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6189;}i:365;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6189;}i:366;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" Statement terminator  ";}i:2;i:6190;}i:367;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6213;}i:368;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6214;}i:369;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6214;}i:370;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6214;}i:371;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" :=  ";}i:2;i:6216;}i:372;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6221;}i:373;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6221;}i:374;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Assignment operator  ";}i:2;i:6222;}i:375;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6244;}i:376;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6245;}i:377;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6245;}i:378;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:6245;}i:379;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6247;}i:380;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:6248;}i:381;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6250;}i:382;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6251;}i:383;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6251;}i:384;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" Association operator  ";}i:2;i:6252;}i:385;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6275;}i:386;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6276;}i:387;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6276;}i:388;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:6276;}i:389;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6278;}i:390;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:6279;}i:391;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"||";}i:2;i:6281;}i:392;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:6283;}i:393;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6285;}i:394;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6286;}i:395;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6286;}i:396;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" Concatenation operator  ";}i:2;i:6287;}i:397;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6312;}i:398;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6313;}i:399;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6313;}i:400;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6313;}i:401;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6315;}i:402;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:6316;}i:403;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"*";}i:2;i:6318;}i:404;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:6319;}i:405;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:6321;}i:406;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"*";}i:2;i:6323;}i:407;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:6324;}i:408;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:6326;}i:409;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6328;}i:410;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6328;}i:411;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" Exponentiation operator  ";}i:2;i:6329;}i:412;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6355;}i:413;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6356;}i:414;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6356;}i:415;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6356;}i:416;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6358;}i:417;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<<";}i:2;i:6359;}i:418;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:", ";}i:2;i:6361;}i:419;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:">>";}i:2;i:6363;}i:420;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:6365;}i:421;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6367;}i:422;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6367;}i:423;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:" Label delimiter (begin and end)  ";}i:2;i:6368;}i:424;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6402;}i:425;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6403;}i:426;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6403;}i:427;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6403;}i:428;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" /*, */  ";}i:2;i:6405;}i:429;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6414;}i:430;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:5:"right";i:2;i:1;}i:2;i:6414;}i:431;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:"  Multi-line comment delimiter (begin and end) ";}i:2;i:6415;}i:432;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6462;}i:433;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6463;}i:434;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6463;}i:435;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:6463;}i:436;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6465;}i:437;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:6466;}i:438;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:6468;}i:439;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6469;}i:440;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6469;}i:441;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:" Single-line comment indicator  ";}i:2;i:6470;}i:442;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6502;}i:443;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6503;}i:444;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6503;}i:445;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:6503;}i:446;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" .. ";}i:2;i:6505;}i:447;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6509;}i:448;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6509;}i:449;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Range operator  ";}i:2;i:6510;}i:450;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6527;}i:451;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6528;}i:452;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6528;}i:453;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6528;}i:454;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" <, >, ";}i:2;i:6530;}i:455;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<=";}i:2;i:6537;}i:456;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:", >=  ";}i:2;i:6539;}i:457;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6545;}i:458;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6545;}i:459;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" Relational operators  ";}i:2;i:6546;}i:460;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6569;}i:461;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6570;}i:462;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:6570;}i:463;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6570;}i:464;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" <>, '=, ~=, ";}i:2;i:6572;}i:465;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:6585;}i:466;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"^=";}i:2;i:6587;}i:467;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:6589;}i:468;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:6591;}i:469;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6593;}i:470;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:6593;}i:471;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:" Different versions of NOT EQUAL  ";}i:2;i:6594;}i:472;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:6628;}i:473;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:6629;}i:474;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:6629;}i:2;i:6629;}i:475;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6632;}i:476;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"The PL/SQL Comments";i:1;i:3;i:2;i:6632;}i:2;i:6632;}i:477;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6632;}i:478;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6632;}i:479;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:199:"Program comments are explanatory statements that you can include in the PL/SQL code that you write and helps anyone reading its source code. All programming languages allow for some form of comments.";}i:2;i:6663;}i:480;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6862;}i:481;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6862;}i:482;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:190:"The PL/SQL supports single-line and multi-line comments. All characters available inside any comment are ignored by PL/SQL compiler. The PL/SQL single-line comments start with the delimiter ";}i:2;i:6864;}i:483;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:7054;}i:484;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:" (double hyphen) and multi-line comments are enclosed by /* and */.";}i:2;i:7056;}i:485;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7124;}i:486;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:176:"DECLARE
   -- variable declaration
   message  varchar2(20):= 'Hello, World!';
BEGIN
   /*
    *  PL/SQL executable statement(s)
    */
   dbms_output.put_line(message);
END;
/";}i:2;i:7124;}i:487;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7124;}i:488;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"When the above code is executed at SQL prompt, it produces the following result:";}i:2;i:7324;}i:489;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7405;}i:490;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:11:"Hello World";}i:2;i:7405;}i:491;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:40:"PL/SQL procedure successfully completed.";}i:2;i:7420;}i:492;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7466;}i:493;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"PL/SQL Program Units";i:1;i:3;i:2;i:7466;}i:2;i:7466;}i:494;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:7466;}i:495;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7466;}i:496;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:"A PL/SQL unit is any one of the following:";}i:2;i:7498;}i:497;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7540;}i:498;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:7540;}i:499;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7540;}i:500;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7540;}i:501;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" PL/SQL block";}i:2;i:7544;}i:502;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7557;}i:503;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7557;}i:504;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7557;}i:505;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7557;}i:506;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Function";}i:2;i:7561;}i:507;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7570;}i:508;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7570;}i:509;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7570;}i:510;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7570;}i:511;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" Package";}i:2;i:7574;}i:512;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7582;}i:513;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7582;}i:514;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7582;}i:515;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7582;}i:516;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Package body";}i:2;i:7586;}i:517;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7599;}i:518;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7599;}i:519;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7599;}i:520;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7599;}i:521;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Procedure";}i:2;i:7603;}i:522;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7613;}i:523;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7613;}i:524;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7613;}i:525;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7613;}i:526;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" Trigger";}i:2;i:7617;}i:527;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7625;}i:528;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7625;}i:529;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7625;}i:530;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7625;}i:531;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" Type";}i:2;i:7629;}i:532;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7634;}i:533;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7634;}i:534;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:7634;}i:535;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:7634;}i:536;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Type body";}i:2;i:7638;}i:537;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:7648;}i:538;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:7648;}i:539;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:7648;}i:540;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7652;}i:541;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"PL/SQL - Data Types";i:1;i:2;i:2;i:7652;}i:2;i:7652;}i:542;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:7652;}i:543;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7652;}i:544;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:182:"PL/SQL variables, constants and parameters must have a valid data type, which specifies a storage format, constraints, and valid range of values. This tutorial will take you through ";}i:2;i:7685;}i:545;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:7867;}i:546;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"SCALAR";}i:2;i:7869;}i:547;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:7875;}i:548;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:7877;}i:549;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:7882;}i:550;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"LOB";}i:2;i:7884;}i:551;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:7887;}i:552;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:" data types available in PL/SQL and other two data types will be covered in other chapters.";}i:2;i:7889;}i:553;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7981;}i:554;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:5;i:2;i:7982;}i:2;i:7981;}i:555;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:7981;}i:556;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:7981;}i:557;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:7981;}i:558;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" Category      ";}i:2;i:7983;}i:559;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:7998;}i:560;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:7998;}i:561;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Description       ";}i:2;i:7999;}i:562;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:8018;}i:563;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8020;}i:564;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:8020;}i:565;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8020;}i:566;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8020;}i:567;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Scalar   ";}i:2;i:8022;}i:568;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8032;}i:569;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8032;}i:570;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:" Single values with no internal components, such as a NUMBER, DATE, or BOOLEAN.  ";}i:2;i:8033;}i:571;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8114;}i:572;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8116;}i:573;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8116;}i:574;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8116;}i:575;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Large Object (LOB)  ";}i:2;i:8118;}i:576;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8139;}i:577;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8139;}i:578;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:142:" Pointers to large objects that are stored separately from other data items, such as text, graphic images, video clips, and sound waveforms.  ";}i:2;i:8140;}i:579;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8282;}i:580;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8283;}i:581;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8283;}i:582;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8283;}i:583;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" Composite  ";}i:2;i:8285;}i:584;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8297;}i:585;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8297;}i:586;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:116:" Data items that have internal components that can be accessed individually. For example, collections and records.  ";}i:2;i:8298;}i:587;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8414;}i:588;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8415;}i:589;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8415;}i:590;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8415;}i:591;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" Reference  ";}i:2;i:8417;}i:592;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8429;}i:593;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8429;}i:594;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:" Pointers to other data items.  ";}i:2;i:8430;}i:595;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8462;}i:596;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8464;}i:597;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:8464;}i:2;i:8464;}i:598;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8466;}i:599;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"PL/SQL Scalar Data Types and Subtypes";i:1;i:3;i:2;i:8466;}i:2;i:8466;}i:600;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:8466;}i:601;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8466;}i:602;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:"PL/SQL Scalar Data Types and Subtypes come under the following categories:";}i:2;i:8515;}i:603;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8590;}i:604;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:5;i:2;i:8591;}i:2;i:8590;}i:605;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:8590;}i:606;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8590;}i:607;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8590;}i:608;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" Data type  ";}i:2;i:8592;}i:609;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:8604;}i:610;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8604;}i:611;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" Description  ";}i:2;i:8605;}i:612;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:8619;}i:613;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8620;}i:614;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:8620;}i:615;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8620;}i:616;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8620;}i:617;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Numeric  ";}i:2;i:8622;}i:618;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8632;}i:619;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8632;}i:620;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:" Numeric values on which arithmetic operations are performed.  ";}i:2;i:8633;}i:621;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8696;}i:622;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8697;}i:623;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8697;}i:624;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8697;}i:625;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" Character  ";}i:2;i:8699;}i:626;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8711;}i:627;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8711;}i:628;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:" Alphanumeric values that represent single characters or strings of characters.  ";}i:2;i:8712;}i:629;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8793;}i:630;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8794;}i:631;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8794;}i:632;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8794;}i:633;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Boolean  ";}i:2;i:8796;}i:634;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8806;}i:635;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8806;}i:636;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" Logical values on which logical operations are performed.  ";}i:2;i:8807;}i:637;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8867;}i:638;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8868;}i:639;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:8868;}i:640;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8868;}i:641;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" Datetime  ";}i:2;i:8870;}i:642;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8881;}i:643;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:8881;}i:644;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Dates and times.  ";}i:2;i:8882;}i:645;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:8901;}i:646;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:8902;}i:647;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:8902;}i:2;i:8902;}i:648;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8902;}i:649;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:287:"PL/SQL provides subtypes of data types. For example, the data type NUMBER has a subtype called INTEGER. You can use subtypes in your PL/SQL program to make the data types compatible with data types in other programs while embedding PL/SQL code in another program, such as a Java program.";}i:2;i:8904;}i:650;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9191;}i:651;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9194;}i:652;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"PL/SQL Numeric Data Types and Subtypes";i:1;i:3;i:2;i:9194;}i:2;i:9194;}i:653;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:9194;}i:654;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9194;}i:655;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"Following is the detail of PL/SQL pre-defined numeric data types and their sub-types:";}i:2;i:9244;}i:656;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9330;}i:657;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:9330;}i:658;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9330;}i:659;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9330;}i:660;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" PLS_INTEGER		Signed integer in range -2,147,483,648 through 2,147,483,647, represented in 32 bits";}i:2;i:9334;}i:661;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9432;}i:662;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9432;}i:663;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9432;}i:664;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9432;}i:665;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:100:" BINARY_INTEGER	Signed integer in range -2,147,483,648 through 2,147,483,647, represented in 32 bits";}i:2;i:9436;}i:666;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9536;}i:667;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9536;}i:668;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9536;}i:669;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9536;}i:670;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:" BINARY_FLOAT	Single-precision IEEE 754-format floating-point number";}i:2;i:9540;}i:671;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9608;}i:672;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9608;}i:673;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9608;}i:674;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9608;}i:675;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" BINARY_DOUBLE	Double-precision IEEE 754-format floating-point number";}i:2;i:9612;}i:676;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9681;}i:677;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9681;}i:678;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9681;}i:679;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9681;}i:680;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:" NUMBER(prec, scale)	Fixed-point or floating-point number with absolute value in range 1E-130 to (but not including) 1.0E126. A NUMBER variable can also represent 0.";}i:2;i:9685;}i:681;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9850;}i:682;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9850;}i:683;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9850;}i:684;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9850;}i:685;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:" DEC(prec, scale)	ANSI specific fixed-point type with maximum precision of 38 decimal digits.";}i:2;i:9854;}i:686;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:9947;}i:687;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:9947;}i:688;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:9947;}i:689;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:9947;}i:690;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:" DECIMAL(prec, scale)	IBM specific fixed-point type with maximum precision of 38 decimal digits.";}i:2;i:9951;}i:691;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10047;}i:692;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10047;}i:693;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10047;}i:694;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10047;}i:695;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:" NUMERIC(pre, secale)	Floating type with maximum precision of 38 decimal digits.";}i:2;i:10051;}i:696;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10131;}i:697;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10131;}i:698;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10131;}i:699;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10131;}i:700;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:" DOUBLE PRECISION	ANSI specific floating-point type with maximum precision of 126 binary digits (approximately 38 decimal digits)";}i:2;i:10135;}i:701;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10264;}i:702;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10264;}i:703;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10264;}i:704;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10264;}i:705;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:" FLOAT	ANSI and IBM specific floating-point type with maximum precision of 126 binary digits (approximately 38 decimal digits)";}i:2;i:10268;}i:706;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10394;}i:707;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10394;}i:708;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10394;}i:709;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10394;}i:710;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:" INT	ANSI specific integer type with maximum precision of 38 decimal digits";}i:2;i:10398;}i:711;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10473;}i:712;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10473;}i:713;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10473;}i:714;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10473;}i:715;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:" INTEGER	ANSI and IBM specific integer type with maximum precision of 38 decimal digits";}i:2;i:10477;}i:716;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10564;}i:717;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10564;}i:718;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10564;}i:719;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10564;}i:720;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:" SMALLINT	ANSI and IBM specific integer type with maximum precision of 38 decimal digits";}i:2;i:10568;}i:721;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10656;}i:722;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10656;}i:723;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:10656;}i:724;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:10656;}i:725;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:102:" REAL	Floating-point type with maximum precision of 63 binary digits (approximately 18 decimal digits)";}i:2;i:10660;}i:726;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:10762;}i:727;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:10762;}i:728;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:10762;}i:729;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10762;}i:730;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"Following is a valid declaration:";}i:2;i:10764;}i:731;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10798;}i:732;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:105:"  DECLARE
     num1 INTEGER;
     num2 REAL;
     num3 DOUBLE PRECISION;
  BEGIN
     null;
  END;
  /
  ";}i:2;i:10798;}i:733;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10923;}i:734;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:40:"PL/SQL Character Data Types and Subtypes";i:1;i:3;i:2;i:10923;}i:2;i:10923;}i:735;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:10923;}i:736;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10923;}i:737;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"Following is the detail of PL/SQL pre-defined character data types and their sub-types:";}i:2;i:10975;}i:738;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11063;}i:739;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:11063;}i:740;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11063;}i:741;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11063;}i:742;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" CHAR	Fixed-length character string with maximum size of 32,767 bytes";}i:2;i:11067;}i:743;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11136;}i:744;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11136;}i:745;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11136;}i:746;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11136;}i:747;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:" VARCHAR2	Variable-length character string with maximum size of 32,767 bytes";}i:2;i:11140;}i:748;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11216;}i:749;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11216;}i:750;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11216;}i:751;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11216;}i:752;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:103:" RAW	Variable-length binary or byte string with maximum size of 32,767 bytes, not interpreted by PL/SQL";}i:2;i:11220;}i:753;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11323;}i:754;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11323;}i:755;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11323;}i:756;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11323;}i:757;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:" NCHAR	Fixed-length national character string with maximum size of 32,767 bytes";}i:2;i:11327;}i:758;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11406;}i:759;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11406;}i:760;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11406;}i:761;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11406;}i:762;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:" NVARCHAR2	Variable-length national character string with maximum size of 32,767 bytes";}i:2;i:11410;}i:763;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11496;}i:764;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11496;}i:765;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11496;}i:766;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11496;}i:767;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:" LONG	Variable-length character string with maximum size of 32,760 bytes";}i:2;i:11500;}i:768;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11572;}i:769;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11572;}i:770;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11572;}i:771;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11572;}i:772;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:" LONG RAW	Variable-length binary or byte string with maximum size of 32,760 bytes, not interpreted by PL/SQL";}i:2;i:11576;}i:773;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11684;}i:774;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11684;}i:775;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11684;}i:776;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11684;}i:777;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:" ROWID	Physical row identifier, the address of a row in an ordinary table";}i:2;i:11688;}i:778;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11761;}i:779;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11761;}i:780;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:11761;}i:781;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:11761;}i:782;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:" UROWID	Universal row identifier (physical, logical, or foreign row identifier)";}i:2;i:11765;}i:783;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:11844;}i:784;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:11844;}i:785;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:11844;}i:786;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:11846;}i:787;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"PL/SQL Boolean Data Types";i:1;i:3;i:2;i:11846;}i:2;i:11846;}i:788;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:11846;}i:789;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11846;}i:790;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:11883;}i:791;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:11887;}i:792;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"BOOLEAN";}i:2;i:11889;}i:793;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:11896;}i:794;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:" data type stores logical values that are used in logical operations. The logical values are the Boolean values TRUE and FALSE and the value NULL.";}i:2;i:11898;}i:795;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12044;}i:796;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12044;}i:797;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:97:"However, SQL has no data type equivalent to BOOLEAN. Therefore, Boolean values cannot be used in:";}i:2;i:12046;}i:798;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12144;}i:799;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:12144;}i:800;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:12144;}i:801;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:12144;}i:802;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" SQL statements";}i:2;i:12148;}i:803;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12163;}i:804;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12163;}i:805;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:12163;}i:806;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:12163;}i:807;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:" Built-in SQL functions (such as TO_CHAR)";}i:2;i:12167;}i:808;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12208;}i:809;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12208;}i:810;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:12208;}i:811;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:12208;}i:812;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:" PL/SQL functions invoked from SQL statements";}i:2;i:12212;}i:813;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:12257;}i:814;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:12257;}i:815;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:12257;}i:816;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:12259;}i:817;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"PL/SQL Datetime and Interval Types";i:1;i:3;i:2;i:12259;}i:2;i:12259;}i:818;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:12259;}i:819;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12259;}i:820;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:12305;}i:821;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:12309;}i:822;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"DATE";}i:2;i:12311;}i:823;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:12315;}i:824;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:" datatype to store fixed-length datetimes, which include the time of day in seconds since midnight. Valid dates range from January 1, 4712 BC to December 31, 9999 AD.";}i:2;i:12317;}i:825;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12483;}i:826;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12483;}i:827;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:289:"The default date format is set by the Oracle initialization parameter NLS_DATE_FORMAT. For example, the default might be 'DD-MON-YY', which includes a two-digit number for the day of the month, an abbreviation of the month name, and the last two digits of the year, for example, 01-OCT-12.";}i:2;i:12485;}i:828;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12774;}i:829;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12774;}i:830;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"Each DATE includes the century, year, month, day, hour, minute, and second. The following table shows the valid values for each field:";}i:2;i:12776;}i:831;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12910;}i:832;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12910;}i:833;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:"^ Field Name  ^ Valid Datetime values  ^ Valid interval values  ^";}i:2;i:12916;}i:834;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12981;}i:835;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:3;i:1;i:10;i:2;i:12982;}i:2;i:12981;}i:836;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:12981;}i:837;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:12981;}i:838;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" YEAR  ";}i:2;i:12983;}i:839;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:12990;}i:840;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:12990;}i:841;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:" -4712 to 9999 (excluding year 0)  ";}i:2;i:12991;}i:842;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13026;}i:843;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13026;}i:844;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Any nonzero integer  ";}i:2;i:13027;}i:845;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13049;}i:846;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13050;}i:847;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13050;}i:848;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13050;}i:849;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" MONTH  ";}i:2;i:13052;}i:850;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13060;}i:851;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13060;}i:852;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 01 to 12  ";}i:2;i:13061;}i:853;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13072;}i:854;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13072;}i:855;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" 0 to 11  ";}i:2;i:13073;}i:856;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13083;}i:857;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13084;}i:858;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13084;}i:859;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13084;}i:860;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" DAY  ";}i:2;i:13086;}i:861;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13092;}i:862;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13092;}i:863;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:" 01 to 31 (limited by the values of MONTH and YEAR, according to the rules of the calendar for the locale)  ";}i:2;i:13093;}i:864;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13201;}i:865;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13201;}i:866;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Any nonzero integer  ";}i:2;i:13202;}i:867;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13224;}i:868;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13225;}i:869;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13225;}i:870;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13225;}i:871;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" HOUR  ";}i:2;i:13227;}i:872;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13234;}i:873;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13234;}i:874;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 00 to 23  ";}i:2;i:13235;}i:875;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13246;}i:876;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13246;}i:877;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" 0 to 23  ";}i:2;i:13247;}i:878;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13257;}i:879;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13258;}i:880;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13258;}i:881;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13258;}i:882;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" MINUTE  ";}i:2;i:13260;}i:883;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13269;}i:884;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13269;}i:885;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 00 to 59  ";}i:2;i:13270;}i:886;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13281;}i:887;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13281;}i:888;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" 0 to 59  ";}i:2;i:13282;}i:889;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13292;}i:890;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13293;}i:891;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13293;}i:892;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13293;}i:893;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" SECOND  ";}i:2;i:13295;}i:894;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13304;}i:895;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13304;}i:896;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:" 00 to 59.9(n), where 9(n) is the precision of time fractional seconds  ";}i:2;i:13305;}i:897;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13377;}i:898;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13377;}i:899;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:" 0 to 59.9(n), where 9(n) is the precision of interval fractional seconds  ";}i:2;i:13378;}i:900;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13453;}i:901;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13454;}i:902;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13454;}i:903;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13454;}i:904;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" TIMEZONE_HOUR  ";}i:2;i:13456;}i:905;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13472;}i:906;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13472;}i:907;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:" -12 to 14 (range accommodates daylight savings time changes)	 ";}i:2;i:13473;}i:908;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13536;}i:909;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13536;}i:910;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Not applicable  ";}i:2;i:13537;}i:911;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13554;}i:912;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13555;}i:913;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13555;}i:914;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13555;}i:915;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" TIMEZONE_MINUTE  ";}i:2;i:13557;}i:916;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13575;}i:917;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13575;}i:918;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" 00 to 59  ";}i:2;i:13576;}i:919;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13587;}i:920;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13587;}i:921;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Not applicable  ";}i:2;i:13588;}i:922;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13605;}i:923;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13606;}i:924;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13606;}i:925;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13606;}i:926;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" TIMEZONE_REGION  ";}i:2;i:13608;}i:927;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13626;}i:928;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13626;}i:929;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:" Found in the dynamic performance view V$TIMEZONE_NAMES  ";}i:2;i:13627;}i:930;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13684;}i:931;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13684;}i:932;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Not applicable  ";}i:2;i:13685;}i:933;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13702;}i:934;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13703;}i:935;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:13703;}i:936;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13703;}i:937;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" TIMEZONE_ABBR  ";}i:2;i:13705;}i:938;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13721;}i:939;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13721;}i:940;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:" Found in the dynamic performance view V$TIMEZONE_NAMES  ";}i:2;i:13722;}i:941;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13779;}i:942;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:13779;}i:943;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Not applicable  ";}i:2;i:13780;}i:944;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:13797;}i:945;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:13798;}i:946;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:13798;}i:2;i:13798;}i:947;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:13801;}i:948;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:36:"PL/SQL Large Object (LOB) Data Types";i:1;i:3;i:2;i:13801;}i:2;i:13801;}i:949;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:13801;}i:950;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13801;}i:951;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:242:"Large object (LOB) data types refer large to data items such as text, graphic images, video clips, and sound waveforms. LOB data types allow efficient, random, piecewise access to this data. Following are the predefined PL/SQL LOB data types:";}i:2;i:13849;}i:952;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14092;}i:953;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:14092;}i:954;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:14092;}i:955;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:14092;}i:956;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:135:" BFILE	Used to store large binary objects in operating system files outside the database.	System-dependent. Cannot exceed 4 gigabytes (";}i:2;i:14096;}i:957;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:2:"GB";}i:2;i:14231;}i:958;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:").";}i:2;i:14233;}i:959;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:14235;}i:960;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:14235;}i:961;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:14235;}i:962;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:14235;}i:963;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:" BLOB	Used to store large binary objects in the database.	8 to 128 terabytes (TB)";}i:2;i:14239;}i:964;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:14320;}i:965;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:14320;}i:966;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:14320;}i:967;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:14320;}i:968;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:" CLOB	Used to store large blocks of character data in the database.	8 to 128 TB";}i:2;i:14324;}i:969;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:14403;}i:970;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:14403;}i:971;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:14403;}i:972;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:14403;}i:973;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:" NCLOB	Used to store large blocks of NCHAR data in the database.	8 to 128 TB";}i:2;i:14407;}i:974;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:14483;}i:975;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:14483;}i:976;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:14483;}i:977;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:14485;}i:978;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:28:"PL/SQL User-Defined Subtypes";i:1;i:3;i:2;i:14485;}i:2;i:14485;}i:979;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:14485;}i:980;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14485;}i:981;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:171:"A subtype is a subset of another data type, which is called its base type. A subtype has the same valid operations as its base type, but only a subset of its valid values.";}i:2;i:14525;}i:982;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14696;}i:983;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14696;}i:984;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"PL/SQL predefines several subtypes in package STANDARD. For example, PL/SQL predefines the subtypes CHARACTER and INTEGER as follows:";}i:2;i:14698;}i:985;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14832;}i:986;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:59:"SUBTYPE CHARACTER IS CHAR;
SUBTYPE INTEGER IS NUMBER(38,0);";}i:2;i:14832;}i:987;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14832;}i:988;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:118:"You can define and use your own subtypes. The following program illustrates defining and using a user-defined subtype:";}i:2;i:14898;}i:989;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15017;}i:990;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:268:"DECLARE
   SUBTYPE name IS char(20);
   SUBTYPE message IS varchar2(100);
   salutation name;
   greetings message;
BEGIN
   salutation := 'Reader ';
   greetings := 'Welcome to the World of PL/SQL';
   dbms_output.put_line('Hello ' || salutation || greetings);
END;
/";}i:2;i:15017;}i:991;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15017;}i:992;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"When the above code is executed at SQL prompt, it produces the following result:";}i:2;i:15310;}i:993;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15391;}i:994;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:43:"Hello Reader Welcome to the World of PL/SQL";}i:2;i:15391;}i:995;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:41:"PL/SQL procedure successfully completed.
";}i:2;i:15438;}i:996;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15485;}i:997;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"NULLs in PL/SQL";i:1;i:3;i:2;i:15485;}i:2;i:15485;}i:998;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:15485;}i:999;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15485;}i:1000;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:299:"PL/SQL NULL values represent missing or unknown data and they are not an integer, a character, or any other specific data type. Note that NULL is not the same as an empty data string or the null character value '\0'. A null can be assigned but it cannot be equated with anything, including itself.  ";}i:2;i:15512;}i:1001;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15811;}i:1002;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15818;}i:1003;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"PL/SQL - Variables";i:1;i:2;i:2;i:15818;}i:2;i:15818;}i:1004;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:15818;}i:1005;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15818;}i:1006;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:324:"A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in PL/SQL has a specific data type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory and the set of operations that can be applied to the variable.";}i:2;i:15850;}i:1007;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16174;}i:1008;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16174;}i:1009;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:290:"The name of a PL/SQL variable consists of a letter optionally followed by more letters, numerals, dollar signs, underscores, and number signs and should not exceed 30 characters. By default, variable names are not case-sensitive. You cannot use a reserved PL/SQL keyword as a variable name.";}i:2;i:16176;}i:1010;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16466;}i:1011;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16466;}i:1012;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:227:"PL/SQL programming language allows to define various types of variables, which we will cover in subsequent chapters like date time data types, records, collections, etc. For this chapter, let us study only basic variable types.";}i:2;i:16468;}i:1013;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16695;}i:1014;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16697;}i:1015;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"Variable Declaration in PL/SQL";i:1;i:3;i:2;i:16697;}i:2;i:16697;}i:1016;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:16697;}i:1017;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16697;}i:1018;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:237:"PL/SQL variables must be declared in the declaration section or in a package as a global variable. When you declare a variable, PL/SQL allocates memory for the variable's value and the storage location is identified by the variable name.";}i:2;i:16740;}i:1019;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16977;}i:1020;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16977;}i:1021;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"The syntax for declaring a variable is:";}i:2;i:16979;}i:1022;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17019;}i:1023;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:73:"variable_name [CONSTANT] datatype [NOT NULL] [:= | DEFAULT initial_value]";}i:2;i:17019;}i:1024;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17019;}i:1025;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:252:"Where, variable_name is a valid identifier in PL/SQL, datatype must be a valid PL/SQL data type or any user defined data type which we already have discussed in last chapter. Some valid variable declarations along with their definition are shown below:";}i:2;i:17097;}i:1026;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17350;}i:1027;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:103:"sales number(10, 2);
pi CONSTANT double precision := 3.1415;
name varchar2(25);
address varchar2(100);
";}i:2;i:17350;}i:1028;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17350;}i:1029;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"When you provide a size, scale or precision limit with the data type, it is called a ";}i:2;i:17465;}i:1030;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:17550;}i:1031;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"constrained declaration";}i:2;i:17552;}i:1032;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:17575;}i:1033;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:". Constrained declarations require less memory than unconstrained declarations. For example:";}i:2;i:17577;}i:1034;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17670;}i:1035;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:62:"sales number(10, 2);
name varchar2(25);
address varchar2(100);";}i:2;i:17670;}i:1036;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:17741;}i:1037;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"Initializing Variables in PL/SQL";i:1;i:3;i:2;i:17741;}i:2;i:17741;}i:1038;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:17741;}i:1039;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17741;}i:1040;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:221:"Whenever you declare a variable, PL/SQL assigns it a default value of NULL. If you want to initialize a variable with a value other than the NULL value, you can do so during the declaration, using either of the following:";}i:2;i:17786;}i:1041;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18008;}i:1042;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:18008;}i:1043;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:18008;}i:1044;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:18008;}i:1045;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" The DEFAULT keyword";}i:2;i:18012;}i:1046;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:18032;}i:1047;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:18032;}i:1048;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:18032;}i:1049;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:18032;}i:1050;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:" The assignment operator";}i:2;i:18036;}i:1051;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:18060;}i:1052;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:18060;}i:1053;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:18060;}i:1054;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18060;}i:1055;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"For example: ";}i:2;i:18062;}i:1056;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18076;}i:1057;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:78:"counter binary_integer := 0;
greetings varchar2(20) DEFAULT 'Have a Good Day';";}i:2;i:18076;}i:1058;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18076;}i:1059;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:"You can also specify that a variable should not have a ";}i:2;i:18161;}i:1060;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:18216;}i:1061;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"NULL";}i:2;i:18218;}i:1062;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:18222;}i:1063;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" value using the ";}i:2;i:18224;}i:1064;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:18241;}i:1065;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"NOT NULL";}i:2;i:18243;}i:1066;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:18251;}i:1067;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:" constraint. If you use the NOT NULL constraint, you must explicitly assign an initial value for that variable.";}i:2;i:18253;}i:1068;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18364;}i:1069;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18364;}i:1070;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:203:"It is a good programming practice to initialize variables properly otherwise, sometimes program would produce unexpected result. Try the following example which makes use of various types of variables:  ";}i:2;i:18366;}i:1071;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18570;}i:1072;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:192:"DECLARE
 a integer := 10;
 b integer := 20;
 c integer;
 f real;
BEGIN
 c := a + b;
 dbms_output.put_line('Value of c: ' || c);
 f := 70.0/3.0;
 dbms_output.put_line('Value of f: ' || f);
END;";}i:2;i:18570;}i:1073;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:18787;}i:1074;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"Variable Scope in PL/SQL";i:1;i:3;i:2;i:18787;}i:2;i:18787;}i:1075;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:18787;}i:1076;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18787;}i:1077;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:342:"PL/SQL allows the nesting of Blocks, i.e., each program block may contain another inner block. If a variable is declared within an inner block, it is not accessible to the outer block. However, if a variable is declared and accessible to an outer Block, it is also accessible to all nested inner Blocks. There are two types of variable scope:";}i:2;i:18824;}i:1078;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19167;}i:1079;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:19167;}i:1080;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:19167;}i:1081;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:19167;}i:1082;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:" Local variables - variables declared in an inner block and not accessible to outer blocks.";}i:2;i:19171;}i:1083;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:19262;}i:1084;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:19262;}i:1085;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:19262;}i:1086;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:19262;}i:1087;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:" Global variables - variables declared in the outermost block or a package.";}i:2;i:19266;}i:1088;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:19341;}i:1089;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:19341;}i:1090;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:19341;}i:1091;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19341;}i:1092;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:"Following example shows the usage of Local and Global variables in its simple form:";}i:2;i:19343;}i:1093;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19427;}i:1094;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:411:"DECLARE
 -- Global variables 
 num1 number := 95; 
 num2 number := 85; 
BEGIN 
 dbms_output.put_line('Outer Variable num1: ' || num1);
 dbms_output.put_line('Outer Variable num2: ' || num2);
 DECLARE 
    -- Local variables
    num1 number := 195; 
    num2 number := 185; 
 BEGIN 
    dbms_output.put_line('Inner Variable num1: ' || num1);
    dbms_output.put_line('Inner Variable num2: ' || num2);
 END; 
END;";}i:2;i:19427;}i:1095;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:19873;}i:1096;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:47:"Assigning SQL Query Results to PL/SQL Variables";i:1;i:3;i:2;i:19873;}i:2;i:19873;}i:1097;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:19873;}i:1098;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19873;}i:1099;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:276:"You can use the SELECT INTO statement of SQL to assign values to PL/SQL variables. For each item in the SELECT list, there must be a corresponding, type-compatible variable in the INTO list. The following example illustrates the concept: Let us create a table named CUSTOMERS:";}i:2;i:19933;}i:1100;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20209;}i:1101;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20209;}i:1102;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"(For SQL statements please look at the ";}i:2;i:20211;}i:1103;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:43:"http://www.tutorialspoint.com/sql/index.htm";i:1;s:12:"SQL tutorial";}i:2;i:20250;}i:1104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:")";}i:2;i:20310;}i:1105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20312;}i:1106;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:166:"CREATE TABLE CUSTOMERS(
 ID   INT NOT NULL,
 NAME VARCHAR (20) NOT NULL,
 AGE INT NOT NULL,
 ADDRESS CHAR (25),
 SALARY   DECIMAL (18, 2),       
 PRIMARY KEY (ID)
);";}i:2;i:20312;}i:1107;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:20312;}i:1108;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:"Next, let us insert some values in the table:";}i:2;i:20497;}i:1109;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20543;}i:1110;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:99:"INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 );";}i:2;i:20543;}i:1111;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:95:"INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (2, 'Khilan', 25, 'Delhi', 1500.00 );";}i:2;i:20648;}i:1112;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:95:"INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (3, 'kaushik', 23, 'Kota', 2000.00 );";}i:2;i:20749;}i:1113;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:98:"INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 );";}i:2;i:20850;}i:1114;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:96:"INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 );";}i:2;i:20954;}i:1115;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:91:"INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (6, 'Komal', 22, 'MP', 4500.00 );";}i:2;i:21056;}i:1116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21056;}i:1117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:"The following program assigns values from the above table to PL/SQL variables using the SELECT INTO clause of SQL:";}i:2;i:21154;}i:1118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21269;}i:1119;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:241:"DECLARE
   c_id customers.id%type := 1;
   c_name  customers.name%type;
   c_addr customers.address%type;
   c_sal  customers.salary%type;
BEGIN
   SELECT name, address, salary INTO c_name, c_addr, c_sal
   FROM customers
   WHERE id = c_id;";}i:2;i:21269;}i:1120;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:99:"   dbms_output.put_line
   ('Customer ' ||c_name || ' from ' || c_addr || ' earns ' || c_sal);
END;";}i:2;i:21530;}i:1121;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21639;}i:1122;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"PL/SQL - Constants and Literals";i:1;i:2;i:2;i:21639;}i:2;i:21639;}i:1123;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:21639;}i:1124;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21639;}i:1125;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:228:"A constant holds a value that once declared, does not change in the program. A constant declaration specifies its name, data type, and value, and allocates storage for it. The declaration can also impose the NOT NULL constraint.";}i:2;i:21684;}i:1126;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21912;}i:1127;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21914;}i:1128;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Declaring a consant";i:1;i:3;i:2;i:21914;}i:2;i:21914;}i:1129;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:21914;}i:1130;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21914;}i:1131;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:137:"A constant is declared using the CONSTANT keyword. It requires an initial value and does not allow that value to be changed. For example:";}i:2;i:21945;}i:1132;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22083;}i:1133;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:34:"PI CONSTANT NUMBER := 3.141592654;";}i:2;i:22083;}i:1134;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:552:"DECLARE
   -- constant declaration
   pi constant number := 3.141592654;
   -- other declarations
   radius number(5,2); 
   dia number(5,2); 
   circumference number(7, 2);
   area number (10, 2);
BEGIN 
   -- processing
   radius := 9.5; 
   dia := radius * 2; 
   circumference := 2.0 * pi * radius;
   area := pi * radius * radius;
   -- output
   dbms_output.put_line('Radius: ' || radius);
   dbms_output.put_line('Diameter: ' || dia);
   dbms_output.put_line('Circumference: ' || circumference);
   dbms_output.put_line('Area: ' || area);
END;
/";}i:2;i:22121;}i:1135;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:22718;}i:1136;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"The PL/SQL Literals";i:1;i:3;i:2;i:22718;}i:2;i:22718;}i:1137;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:22718;}i:1138;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22718;}i:1139;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:289:"A literal is an explicit numeric, character, string, or Boolean value not represented by an identifier. For example, TRUE, 786, NULL, 'tutorialspoint' are all literals of type Boolean, number, or string. PL/SQL, literals are case-sensitive. PL/SQL supports the following kinds of literals:";}i:2;i:22749;}i:1140;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23039;}i:1141;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:23039;}i:1142;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23039;}i:1143;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23039;}i:1144;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Numeric Literals";}i:2;i:23043;}i:1145;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23060;}i:1146;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23060;}i:1147;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23060;}i:1148;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23060;}i:1149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Character Literals";}i:2;i:23064;}i:1150;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23083;}i:1151;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23083;}i:1152;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23083;}i:1153;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23083;}i:1154;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" String Literals";}i:2;i:23087;}i:1155;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23103;}i:1156;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23103;}i:1157;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23103;}i:1158;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23103;}i:1159;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" BOOLEAN Literals";}i:2;i:23107;}i:1160;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23124;}i:1161;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23124;}i:1162;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:23124;}i:1163;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:23124;}i:1164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" Date and Time Literals";}i:2;i:23128;}i:1165;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:23151;}i:1166;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:23151;}i:1167;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:23151;}i:1168;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23151;}i:1169;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:"The following table provides examples from all these categories of literal values.";}i:2;i:23153;}i:1170;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23236;}i:1171;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:134:"050 78 -14 0 +32767
6.6667 0.0 -12.0 3.14159 +7800.00
6E5 1.0E-8 3.14159e0 -1E38 -9.5e-3
'Hello, world!'
'Tutorials Point'
'19-NOV-12'";}i:2;i:23236;}i:1172;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:6;i:2;i:23385;}i:2;i:23384;}i:1173;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:23384;}i:1174;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:23384;}i:1175;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23384;}i:1176;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" Literal type  ";}i:2;i:23386;}i:1177;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:23401;}i:1178;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23401;}i:1179;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" Example   ";}i:2;i:23402;}i:1180;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:23413;}i:1181;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:23414;}i:1182;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:23414;}i:1183;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:23414;}i:1184;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:2;i:1;s:4:"left";i:2;i:1;}i:2;i:23414;}i:1185;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Numeric Literals  ";}i:2;i:23416;}i:1186;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23435;}i:1187;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:23437;}i:1188;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:23437;}i:1189;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23437;}i:1190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Character Literals  ";}i:2;i:23439;}i:1191;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23460;}i:1192;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23460;}i:1193;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" 'A' '%' '9' ' ' 'z' '('  ";}i:2;i:23461;}i:1194;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23487;}i:1195;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:23488;}i:1196;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:23488;}i:1197;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:2;i:1;s:4:"left";i:2;i:1;}i:2;i:23488;}i:1198;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" String Literals  ";}i:2;i:23490;}i:1199;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23508;}i:1200;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:23510;}i:1201;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:23510;}i:1202;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23510;}i:1203;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" BOOLEAN Literals  ";}i:2;i:23512;}i:1204;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23531;}i:1205;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23531;}i:1206;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" TRUE, FALSE and NULL  ";}i:2;i:23532;}i:1207;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23555;}i:1208;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:23556;}i:1209;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:23556;}i:1210;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23556;}i:1211;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" Date and Time Literals  ";}i:2;i:23558;}i:1212;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23583;}i:1213;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:23583;}i:1214;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" DATE '1978-12-25'; ";}i:2;i:23584;}i:1215;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:23604;}i:1216;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"TIMESTAMP '2012-10-29 12:01:01';   ";}i:2;i:23607;}i:1217;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:23642;}i:1218;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:23643;}i:1219;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:23643;}i:2;i:23643;}i:1220;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23643;}i:1221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:"To embed single quotes within a string literal, place two single quotes next to each other as shown below:";}i:2;i:23645;}i:1222;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23752;}i:1223;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:114:"DECLARE
   message  varchar2(30):= ''That''s tutorialspoint.com!'';
BEGIN
   dbms_output.put_line(message);
END;
/";}i:2;i:23752;}i:1224;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:23882;}i:1225;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"PL/SQL - Operators";i:1;i:2;i:2;i:23882;}i:2;i:23882;}i:1226;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:23882;}i:1227;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23882;}i:1228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:198:"An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulation. PL/SQL language is rich in built-in operators and provides the following types of operators:";}i:2;i:23914;}i:1229;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24113;}i:1230;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:24113;}i:1231;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:24113;}i:1232;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:24113;}i:1233;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Arithmetic operators";}i:2;i:24117;}i:1234;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:24138;}i:1235;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:24138;}i:1236;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:24138;}i:1237;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:24138;}i:1238;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Relational operators";}i:2;i:24142;}i:1239;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:24163;}i:1240;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:24163;}i:1241;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:24163;}i:1242;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:24163;}i:1243;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Comparison operators";}i:2;i:24167;}i:1244;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:24188;}i:1245;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:24188;}i:1246;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:24188;}i:1247;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:24188;}i:1248;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" Logical operators";}i:2;i:24192;}i:1249;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:24210;}i:1250;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:24210;}i:1251;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:24210;}i:1252;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:24210;}i:1253;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" String operators";}i:2;i:24214;}i:1254;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:24231;}i:1255;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:24231;}i:1256;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:24231;}i:1257;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24231;}i:1258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"This tutorial will explain the arithmetic, relational, comparison and logical operators one by one. The String operators will be discussed under the chapter: ";}i:2;i:24233;}i:1259;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:24391;}i:1260;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"PL/SQL - Strings";}i:2;i:24393;}i:1261;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:24409;}i:1262;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:" (LINK).";}i:2;i:24411;}i:1263;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24419;}i:1264;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:24421;}i:1265;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Arithmetic Operators";i:1;i:3;i:2;i:24421;}i:2;i:24421;}i:1266;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:24421;}i:1267;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24421;}i:1268;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:"Following table shows all the arithmetic operators supported by PL/SQL. Assume variable A holds 10 and variable B holds 5 then:";}i:2;i:24453;}i:1269;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24581;}i:1270;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:3;i:1;i:6;i:2;i:24582;}i:2;i:24581;}i:1271;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:24581;}i:1272;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:24581;}i:1273;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24581;}i:1274;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Operator ";}i:2;i:24583;}i:1275;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:24593;}i:1276;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24593;}i:1277;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:24594;}i:1278;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:24607;}i:1279;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24607;}i:1280;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Example ";}i:2;i:24608;}i:1281;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:24617;}i:1282;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:24618;}i:1283;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:24618;}i:1284;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:24618;}i:1285;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24618;}i:1286;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" + ";}i:2;i:24620;}i:1287;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24623;}i:1288;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24623;}i:1289;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Adds two operands ";}i:2;i:24624;}i:1290;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24643;}i:1291;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24643;}i:1292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" A + B will give 15 ";}i:2;i:24644;}i:1293;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24664;}i:1294;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:24665;}i:1295;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:24665;}i:1296;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24665;}i:1297;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" - ";}i:2;i:24667;}i:1298;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24670;}i:1299;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24670;}i:1300;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:" Substracts second operand from the first ";}i:2;i:24671;}i:1301;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24713;}i:1302;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24713;}i:1303;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" A - B will give 5 ";}i:2;i:24714;}i:1304;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24733;}i:1305;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:24734;}i:1306;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:24734;}i:1307;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24734;}i:1308;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" * ";}i:2;i:24736;}i:1309;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24739;}i:1310;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24739;}i:1311;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" Multiplies both operands ";}i:2;i:24740;}i:1312;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24766;}i:1313;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24766;}i:1314;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" A * B will give 50 ";}i:2;i:24767;}i:1315;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24787;}i:1316;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:24788;}i:1317;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:24788;}i:1318;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24788;}i:1319;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" / ";}i:2;i:24790;}i:1320;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24793;}i:1321;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24793;}i:1322;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:" Divides numerator by de-numerator ";}i:2;i:24794;}i:1323;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24829;}i:1324;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24829;}i:1325;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" A / B will give 2 ";}i:2;i:24830;}i:1326;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24849;}i:1327;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:24850;}i:1328;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:24850;}i:1329;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24850;}i:1330;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" * * ";}i:2;i:24852;}i:1331;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24857;}i:1332;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24857;}i:1333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:" Exponentiation operator, raises one operand to the power of other ";}i:2;i:24858;}i:1334;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24925;}i:1335;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:24925;}i:1336;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:" * * B will give 100000 ";}i:2;i:24926;}i:1337;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:24950;}i:1338;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:24951;}i:1339;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:24951;}i:2;i:24951;}i:1340;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:24953;}i:1341;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Relational operators";i:1;i:3;i:2;i:24953;}i:2;i:24953;}i:1342;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:24953;}i:1343;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24953;}i:1344;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:213:"Relational operators compare two expressions or values and return a Boolean result. Following table shows all the relational operators supported by PL/SQL. Assume variable A holds 10 and variable B holds 20, then:";}i:2;i:24985;}i:1345;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25198;}i:1346;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25198;}i:1347;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"!=";}i:2;i:25200;}i:1348;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25202;}i:1349;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25202;}i:1350;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"<>";}i:2;i:25204;}i:1351;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25206;}i:1352;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25206;}i:1353;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"~=";}i:2;i:25208;}i:1354;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25211;}i:1355;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:3;i:1;i:7;i:2;i:25212;}i:2;i:25211;}i:1356;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:25211;}i:1357;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25211;}i:1358;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25211;}i:1359;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Operator ";}i:2;i:25213;}i:1360;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:25223;}i:1361;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25223;}i:1362;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:25224;}i:1363;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:25237;}i:1364;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25237;}i:1365;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Example ";}i:2;i:25238;}i:1366;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:25247;}i:1367;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:25248;}i:1368;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:25248;}i:1369;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25248;}i:1370;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25248;}i:1371;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" = ";}i:2;i:25250;}i:1372;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25253;}i:1373;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25253;}i:1374;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:" Checks if the values of two operands are equal or not, if yes then condition becomes true. ";}i:2;i:25254;}i:1375;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25346;}i:1376;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25346;}i:1377;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" (A = B) is not true. ";}i:2;i:25347;}i:1378;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25369;}i:1379;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:25370;}i:1380;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25370;}i:1381;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25370;}i:1382;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:" Checks if the values of two operands are equal or not, if values are not equal then condition becomes true. ";}i:2;i:25372;}i:1383;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25481;}i:1384;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:2;i:1;N;i:2;i:1;}i:2;i:25481;}i:1385;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" (A != B) is true. ";}i:2;i:25482;}i:1386;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25501;}i:1387;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:25503;}i:1388;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25503;}i:1389;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25503;}i:1390;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" > ";}i:2;i:25505;}i:1391;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25508;}i:1392;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25508;}i:1393;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:" Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true. ";}i:2;i:25509;}i:1394;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25626;}i:1395;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25626;}i:1396;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" (A > B) is not true. ";}i:2;i:25627;}i:1397;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25649;}i:1398;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:25650;}i:1399;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25650;}i:1400;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25650;}i:1401;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" < ";}i:2;i:25652;}i:1402;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25655;}i:1403;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25655;}i:1404;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:" Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true. ";}i:2;i:25656;}i:1405;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25770;}i:1406;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25770;}i:1407;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" (A < B) is true. ";}i:2;i:25771;}i:1408;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25789;}i:1409;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:25790;}i:1410;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25790;}i:1411;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25790;}i:1412;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" >= ";}i:2;i:25792;}i:1413;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25796;}i:1414;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25796;}i:1415;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:" Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true. ";}i:2;i:25797;}i:1416;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25926;}i:1417;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25926;}i:1418;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:" (A >= B) is not true. ";}i:2;i:25927;}i:1419;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25950;}i:1420;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:25951;}i:1421;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:25951;}i:1422;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25951;}i:1423;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:25953;}i:1424;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<=";}i:2;i:25954;}i:1425;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:25956;}i:1426;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:25957;}i:1427;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:25957;}i:1428;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:" Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true. ";}i:2;i:25958;}i:1429;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26084;}i:1430;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26084;}i:1431;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" A ";}i:2;i:26085;}i:1432;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<=";}i:2;i:26088;}i:1433;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" B) is true. ";}i:2;i:26090;}i:1434;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26103;}i:1435;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:26104;}i:1436;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:26104;}i:2;i:26104;}i:1437;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:26107;}i:1438;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Comparison operator";i:1;i:3;i:2;i:26107;}i:2;i:26107;}i:1439;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:26107;}i:1440;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:26107;}i:1441;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"Comparison operators are used for comparing one expression to another. The result is always either TRUE, FALSE OR NULL.";}i:2;i:26138;}i:1442;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26258;}i:1443;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:3;i:1;i:5;i:2;i:26259;}i:2;i:26258;}i:1444;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:26258;}i:1445;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:26258;}i:1446;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26258;}i:1447;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Operator ";}i:2;i:26260;}i:1448;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:26270;}i:1449;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26270;}i:1450;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:26271;}i:1451;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:26284;}i:1452;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26284;}i:1453;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Example ";}i:2;i:26285;}i:1454;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:26294;}i:1455;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:26295;}i:1456;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:26295;}i:1457;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:26295;}i:1458;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26295;}i:1459;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" LIKE ";}i:2;i:26297;}i:1460;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26303;}i:1461;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26303;}i:1462;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:" The LIKE operator compares a character, string, or CLOB value to a pattern and returns TRUE if the value matches the pattern and FALSE if it does not. ";}i:2;i:26304;}i:1463;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26456;}i:1464;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26456;}i:1465;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:112:" If 'Zara Ali' like 'Z% A_i' returns a Boolean true, whereas, 'Nuha Ali' like 'Z% A_i' returns a Boolean false. ";}i:2;i:26457;}i:1466;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26569;}i:1467;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:26570;}i:1468;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:26570;}i:1469;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26570;}i:1470;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" BETWEEN ";}i:2;i:26572;}i:1471;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26581;}i:1472;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26581;}i:1473;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:" The BETWEEN operator tests whether a value lies in a specified range. x BETWEEN a AND b means that x >= a and x ";}i:2;i:26582;}i:1474;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<=";}i:2;i:26695;}i:1475;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" b. ";}i:2;i:26697;}i:1476;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26701;}i:1477;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26701;}i:1478;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:122:" If x = 10 then, x between 5 and 20 returns true, x between 5 and 10 returns true, but x between 11 and 20 returns false. ";}i:2;i:26702;}i:1479;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26824;}i:1480;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:26825;}i:1481;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:26825;}i:1482;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26825;}i:1483;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" IN ";}i:2;i:26827;}i:1484;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26831;}i:1485;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26831;}i:1486;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:94:" The IN operator tests set membership. x IN (set) means that x is equal to any member of set. ";}i:2;i:26832;}i:1487;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:26926;}i:1488;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:26926;}i:1489;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:" If x = 'm' then, x in ('a', 'b', 'c') returns boolean false but x in ('m', 'n', 'o') returns Boolean true. ";}i:2;i:26927;}i:1490;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27035;}i:1491;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:27036;}i:1492;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:27036;}i:1493;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27036;}i:1494;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" IS NULL ";}i:2;i:27038;}i:1495;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27047;}i:1496;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27047;}i:1497;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:157:" The IS NULL operator returns the BOOLEAN value TRUE if its operand is NULL or FALSE if it is not NULL. Comparisons involving NULL values always yield NULL. ";}i:2;i:27048;}i:1498;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27205;}i:1499;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27205;}i:1500;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:53:" If x = 'm', then 'x is null' returns Boolean false. ";}i:2;i:27206;}i:1501;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27259;}i:1502;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:27260;}i:1503;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:27260;}i:2;i:27260;}i:1504;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:27262;}i:1505;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"Logical operators";i:1;i:3;i:2;i:27262;}i:2;i:27262;}i:1506;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:27262;}i:1507;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27262;}i:1508;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:202:"Following table shows the Logical operators supported by PL/SQL. All these operators work on Boolean operands and produces Boolean results. Assume variable A holds true and variable B holds false, then:";}i:2;i:27291;}i:1509;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:27494;}i:1510;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:3;i:1;i:4;i:2;i:27495;}i:2;i:27494;}i:1511;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:27494;}i:1512;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:27494;}i:1513;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27494;}i:1514;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Operator ";}i:2;i:27496;}i:1515;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:27506;}i:1516;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27506;}i:1517;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:27507;}i:1518;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:27520;}i:1519;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27520;}i:1520;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Example ";}i:2;i:27521;}i:1521;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:27530;}i:1522;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:27531;}i:1523;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:27531;}i:1524;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:27531;}i:1525;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27531;}i:1526;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:27533;}i:1527;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27538;}i:1528;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:27538;}i:1529;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:" Called logical AND operator. If both the operands are true then condition becomes true.	 ";}i:2;i:27539;}i:1530;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27629;}i:1531;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27629;}i:1532;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" (A and B) is false. ";}i:2;i:27630;}i:1533;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27651;}i:1534;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:27652;}i:1535;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:27652;}i:1536;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27652;}i:1537;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" or ";}i:2;i:27654;}i:1538;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27658;}i:1539;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27658;}i:1540;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:" Called logical OR Operator. If any of the two operands is true then condition becomes true. ";}i:2;i:27659;}i:1541;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27752;}i:1542;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27752;}i:1543;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" (A or B) is true. ";}i:2;i:27753;}i:1544;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27772;}i:1545;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:27773;}i:1546;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:27773;}i:1547;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27773;}i:1548;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" not ";}i:2;i:27775;}i:1549;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27780;}i:1550;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27780;}i:1551;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:149:" Called logical NOT Operator. Used to reverse the logical state of its operand. If a condition is true then Logical NOT operator will make it false. ";}i:2;i:27781;}i:1552;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27930;}i:1553;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:27930;}i:1554;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:" not (A and B) is true. ";}i:2;i:27931;}i:1555;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:27955;}i:1556;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:27956;}i:1557;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:27956;}i:2;i:27956;}i:1558;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:27958;}i:1559;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"PL/SQL Operator Precedence";i:1;i:3;i:2;i:27958;}i:2;i:27958;}i:1560;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:27958;}i:1561;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27958;}i:1562;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:260:"Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:";}i:2;i:27996;}i:1563;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28256;}i:1564;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28256;}i:1565;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:"For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.";}i:2;i:28258;}i:1566;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28423;}i:1567;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28423;}i:1568;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:194:"Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.";}i:2;i:28425;}i:1569;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28619;}i:1570;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28619;}i:1571;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"=, <, >, ";}i:2;i:28621;}i:1572;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<=";}i:2;i:28630;}i:1573;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:", >=, <>, !=, ~=, ^=,";}i:2;i:28632;}i:1574;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28653;}i:1575;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28653;}i:1576;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"IS NULL, LIKE, BETWEEN, IN";}i:2;i:28655;}i:1577;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28682;}i:1578;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:9;i:2;i:28683;}i:2;i:28682;}i:1579;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:28682;}i:1580;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28682;}i:1581;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28682;}i:1582;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" Operator ";}i:2;i:28684;}i:1583;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:28694;}i:1584;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28694;}i:1585;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" Operation ";}i:2;i:28695;}i:1586;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:28706;}i:1587;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28708;}i:1588;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:28708;}i:1589;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28708;}i:1590;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28708;}i:1591;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" * * ";}i:2;i:28710;}i:1592;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28715;}i:1593;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28715;}i:1594;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" exponentiation ";}i:2;i:28716;}i:1595;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28732;}i:1596;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28733;}i:1597;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28733;}i:1598;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28733;}i:1599;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" +,- ";}i:2;i:28735;}i:1600;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28740;}i:1601;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28740;}i:1602;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" identity, negation ";}i:2;i:28741;}i:1603;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28761;}i:1604;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28762;}i:1605;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28762;}i:1606;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28762;}i:1607;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" *, / ";}i:2;i:28764;}i:1608;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28770;}i:1609;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28770;}i:1610;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" multiplication, division ";}i:2;i:28771;}i:1611;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28797;}i:1612;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28798;}i:1613;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28798;}i:1614;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28798;}i:1615;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:" +, -, ";}i:2;i:28800;}i:1616;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:28807;}i:1617;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"||";}i:2;i:28809;}i:1618;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:28811;}i:1619;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:28813;}i:1620;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28814;}i:1621;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28814;}i:1622;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:" addition, subtraction, concatenation ";}i:2;i:28815;}i:1623;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28853;}i:1624;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28854;}i:1625;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28854;}i:1626;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:2;i:1;N;i:2;i:1;}i:2;i:28854;}i:1627;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" comparison ";}i:2;i:28856;}i:1628;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28868;}i:1629;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28870;}i:1630;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28870;}i:1631;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28870;}i:1632;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" NOT ";}i:2;i:28872;}i:1633;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28877;}i:1634;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28877;}i:1635;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" logical negation ";}i:2;i:28878;}i:1636;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28896;}i:1637;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28897;}i:1638;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28897;}i:1639;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28897;}i:1640;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" AND ";}i:2;i:28899;}i:1641;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28904;}i:1642;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28904;}i:1643;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" conjunction ";}i:2;i:28905;}i:1644;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28918;}i:1645;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28919;}i:1646;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:28919;}i:1647;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28919;}i:1648;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" OR ";}i:2;i:28921;}i:1649;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28925;}i:1650;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:28925;}i:1651;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" inclusion ";}i:2;i:28926;}i:1652;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:28937;}i:1653;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:28938;}i:1654;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:28938;}i:2;i:28938;}i:1655;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28938;}i:1656;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"Example:";}i:2;i:28940;}i:1657;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28948;}i:1658;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:6:"hidden";i:1;a:11:{s:6:"active";s:4:"true";s:7:"element";a:0:{}s:8:"onHidden";s:4:"Kuva";s:9:"onVisible";s:5:"Peida";s:12:"initialState";s:6:"hidden";s:5:"state";i:1;s:9:"printHead";b:1;s:13:"bytepos_start";i:28950;s:4:"edit";b:0;s:8:"editText";s:19:"Edit hidden section";s:11:"onExportPdf";s:5:"Peida";}i:2;i:1;i:3;s:8:"<hidden>";}i:2;i:28950;}i:1659;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:581:"DECLARE
   a number(2) := 20;
   b number(2) := 10;
   c number(2) := 15;
   d number(2) := 5;
   e number(2) ;
BEGIN
   e := (a + b) * c / d;      -- ( 30 * 15 ) / 5
   dbms_output.put_line('Value of (a + b) * c / d is : '|| e );
   e := ((a + b) * c) / d;   -- (30 * 15 ) / 5
   dbms_output.put_line('Value of ((a + b) * c) / d is  : ' ||  e );
   e := (a + b) * (c / d);   -- (30) * (15/5)
   dbms_output.put_line('Value of (a + b) * (c / d) is  : '||  e );
   e := a + (b * c) / d;     --  20 + (150/5)
   dbms_output.put_line('Value of a + (b * c) / d is  : ' ||  e );
END;
/
";}i:2;i:28959;}i:1660;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:6:"hidden";i:1;a:2:{s:5:"state";i:4;s:11:"bytepos_end";i:29587;}i:2;i:4;i:3;s:9:"</hidden>";}i:2;i:29578;}i:1661;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:29590;}i:1662;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"PL/SQL - Conditions";i:1;i:2;i:2;i:29590;}i:2;i:29590;}i:1663;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:29590;}i:1664;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29590;}i:1665;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:314:"Decision-making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.";}i:2;i:29623;}i:1666;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:29937;}i:1667;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29937;}i:1668;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:"Following is the general from of a typical conditional (i.e., decision making) structure found in most of the programming languages:";}i:2;i:29939;}i:1669;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:30071;}i:1670;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:30071;}i:1671;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:27:":nortal:decision_making.jpg";i:1;s:0:"";i:2;N;i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:6:"nolink";}i:2;i:30073;}i:1672;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:30112;}i:1673;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:30112;}i:1674;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:"PL/SQL programming language provides following types of decision-making statements. Click the following links to check their detail.";}i:2;i:30114;}i:1675;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:30247;}i:1676;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:7;i:2;i:30248;}i:2;i:30247;}i:1677;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:30247;}i:1678;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:30247;}i:1679;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30247;}i:1680;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" Statement ";}i:2;i:30249;}i:1681;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:30260;}i:1682;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30260;}i:1683;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:30261;}i:1684;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:30274;}i:1685;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:30275;}i:1686;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:30275;}i:1687;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:30275;}i:1688;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30275;}i:1689;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" IF - THEN statement ";}i:2;i:30277;}i:1690;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30298;}i:1691;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30298;}i:1692;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:241:" The IF statement associates a condition with a sequence of statements enclosed by the keywords THEN and END IF. If the condition is true, the statements get executed and if the condition is false or NULL then the IF statement does nothing. ";}i:2;i:30299;}i:1693;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30540;}i:1694;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:30541;}i:1695;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:30541;}i:1696;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30541;}i:1697;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:" IF-THEN-ELSE statement ";}i:2;i:30543;}i:1698;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30567;}i:1699;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30567;}i:1700;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:251:" IF statement adds the keyword ELSE followed by an alternative sequence of statement. If the condition is false or NULL , then only the alternative sequence of statements get executed. It ensures that either of the sequence of statements is executed. ";}i:2;i:30568;}i:1701;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30819;}i:1702;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:30820;}i:1703;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:30820;}i:1704;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30820;}i:1705;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" IF-THEN-ELSIF statement ";}i:2;i:30822;}i:1706;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30847;}i:1707;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30847;}i:1708;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:" It allows you to choose between several alternatives. ";}i:2;i:30848;}i:1709;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30903;}i:1710;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:30904;}i:1711;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:30904;}i:1712;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30904;}i:1713;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" Case statement ";}i:2;i:30906;}i:1714;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:30922;}i:1715;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:30922;}i:1716;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:287:" Like the IF statement, the CASE statement selects one sequence of statements to execute. However, to select the sequence, the CASE statement uses a selector rather than multiple Boolean expressions. A selector is an expression whose value is used to select one of several alternatives. ";}i:2;i:30923;}i:1717;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:31210;}i:1718;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:31211;}i:1719;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:31211;}i:1720;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:31211;}i:1721;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" Searched CASE statement ";}i:2;i:31213;}i:1722;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:31238;}i:1723;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:31238;}i:1724;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:" The searched CASE statement has no selector, and it's WHEN clauses contain search conditions that yield Boolean values. ";}i:2;i:31239;}i:1725;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:31360;}i:1726;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:31361;}i:1727;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:31361;}i:1728;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:31361;}i:1729;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" nested IF-THEN-ELSE ";}i:2;i:31363;}i:1730;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:31384;}i:1731;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:31384;}i:1732;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:" You can use one IF-THEN or IF-THEN-ELSIF statement inside another IF-THEN or IF-THEN-ELSIF statement(s). ";}i:2;i:31385;}i:1733;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:31491;}i:1734;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:31492;}i:1735;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:31492;}i:2;i:31492;}i:1736;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:31494;}i:1737;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"PL/SQL - Loops";i:1;i:2;i:2;i:31494;}i:2;i:31494;}i:1738;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:31494;}i:1739;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:31494;}i:1740;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:228:"There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.";}i:2;i:31522;}i:1741;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:31750;}i:1742;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:31750;}i:1743;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:105:"Programming languages provide various control structures that allow for more complicated execution paths.";}i:2;i:31752;}i:1744;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:31857;}i:1745;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:31857;}i:1746;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:179:"A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:";}i:2;i:31859;}i:1747;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32038;}i:1748;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32038;}i:1749;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:29:":nortal:loop_architecture.jpg";i:1;s:0:"";i:2;N;i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:6:"nolink";}i:2;i:32040;}i:1750;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32081;}i:1751;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32081;}i:1752;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:228:"There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.";}i:2;i:32083;}i:1753;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32311;}i:1754;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32311;}i:1755;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:105:"Programming languages provide various control structures that allow for more complicated execution paths.";}i:2;i:32313;}i:1756;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32418;}i:1757;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32418;}i:1758;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:179:"A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:";}i:2;i:32420;}i:1759;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32600;}i:1760;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:5;i:2;i:32601;}i:2;i:32600;}i:1761;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:32600;}i:1762;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:32600;}i:1763;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:32600;}i:1764;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" Loop Type ";}i:2;i:32602;}i:1765;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:32613;}i:1766;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:32613;}i:1767;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:32614;}i:1768;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:32627;}i:1769;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:32628;}i:1770;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:32628;}i:1771;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:32628;}i:1772;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:32628;}i:1773;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" LOOP Basic ";}i:2;i:32630;}i:1774;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:32642;}i:1775;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:32642;}i:1776;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:209:" In this loop structure, sequence of statements is enclosed between the LOOP and END LOOP statements. At each iteration, the sequence of statements is executed and then control resumes at the top of the loop. ";}i:2;i:32643;}i:1777;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:32852;}i:1778;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:32853;}i:1779;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:32853;}i:1780;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:32853;}i:1781;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" LOOP WHILE ";}i:2;i:32855;}i:1782;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:32867;}i:1783;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:32867;}i:1784;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:" Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body. ";}i:2;i:32868;}i:1785;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:33000;}i:1786;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:33001;}i:1787;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:33001;}i:1788;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:33001;}i:1789;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" LOOP FOR ";}i:2;i:33003;}i:1790;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:33013;}i:1791;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:33013;}i:1792;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:" Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable. ";}i:2;i:33014;}i:1793;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:33120;}i:1794;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:33121;}i:1795;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:33121;}i:1796;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:33121;}i:1797;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:" Nested loops in PL/SQL ";}i:2;i:33123;}i:1798;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:33147;}i:1799;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:33147;}i:1800;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:" You can use one or more loop inside any another basic loop, while or for loop. ";}i:2;i:33148;}i:1801;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:33228;}i:1802;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:33229;}i:1803;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:33229;}i:2;i:33229;}i:1804;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:33231;}i:1805;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"Labeling a PL/SQL Loop";i:1;i:3;i:2;i:33231;}i:2;i:33231;}i:1806;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:33231;}i:1807;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:33231;}i:1808;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"PL/SQL loops can be labeled. The label should be enclosed by double angle brackets (";}i:2;i:33265;}i:1809;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"<<";}i:2;i:33349;}i:1810;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:33351;}i:1811;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:">>";}i:2;i:33356;}i:1812;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:184:") and appear at the beginning of the LOOP statement. The label name can also appear at the end of the LOOP statement. You may use the label in the EXIT statement to exit from the loop.";}i:2;i:33358;}i:1813;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:33542;}i:1814;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:33542;}i:1815;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"The following program illustrates the concept:";}i:2;i:33544;}i:1816;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:33591;}i:1817;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:260:"DECLARE
   i number(1);
   j number(1);
BEGIN
   << outer_loop >>
   FOR i IN 1..3 LOOP
      << inner_loop >>
      FOR j IN 1..3 LOOP
         dbms_output.put_line('i is: '|| i || ' and j is: ' || j);
      END loop inner_loop;
   END loop outer_loop;
END;
/";}i:2;i:33591;}i:1818;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:33880;}i:1819;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"The Loop Control Statements";i:1;i:3;i:2;i:33880;}i:2;i:33880;}i:1820;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:33880;}i:1821;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:33880;}i:1822;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.";}i:2;i:33919;}i:1823;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34085;}i:1824;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34085;}i:1825;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:163:"PL/SQL supports the following control statements. Labeling loops also helps in taking the control outside a loop. Click the following links to check their details.";}i:2;i:34087;}i:1826;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34251;}i:1827;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:4;i:2;i:34252;}i:2;i:34251;}i:1828;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:34251;}i:1829;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:34251;}i:1830;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34251;}i:1831;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:" Control Statement ";}i:2;i:34253;}i:1832;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:34272;}i:1833;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34272;}i:1834;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" Description ";}i:2;i:34273;}i:1835;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:34286;}i:1836;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:34287;}i:1837;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:34287;}i:1838;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:34287;}i:1839;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34287;}i:1840;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" EXIT statement ";}i:2;i:34289;}i:1841;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:34305;}i:1842;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34305;}i:1843;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:102:" The Exit statement completes the loop and control passes to the statement immediately after END LOOP ";}i:2;i:34306;}i:1844;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:34408;}i:1845;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:34409;}i:1846;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:34409;}i:1847;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34409;}i:1848;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" CONTINUE statement ";}i:2;i:34411;}i:1849;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:34431;}i:1850;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34431;}i:1851;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:" Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating. ";}i:2;i:34432;}i:1852;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:34542;}i:1853;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:34543;}i:1854;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:34543;}i:1855;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34543;}i:1856;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" GOTO statement ";}i:2;i:34545;}i:1857;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:34561;}i:1858;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:34561;}i:1859;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:" Transfers control to the labeled statement. Though it is not advised to use GOTO statement in your program. ";}i:2;i:34562;}i:1860;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:34671;}i:1861;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:34672;}i:1862;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:34672;}i:2;i:34672;}i:1863;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:34674;}i:1864;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"PL/SQL - Strings";i:1;i:1;i:2;i:34674;}i:2;i:34674;}i:1865;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:34674;}i:1866;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34674;}i:1867;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:225:"The string in PL/SQL is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. PL/SQL offers three kinds of strings:";}i:2;i:34706;}i:1868;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34932;}i:1869;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:34932;}i:1870;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:34932;}i:1871;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:34932;}i:1872;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:" Fixed-length strings: In such strings, programmers specify the length while declaring the string. The string is right-padded with spaces to the length so specified.";}i:2;i:34936;}i:1873;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:35101;}i:1874;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:35101;}i:1875;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:35101;}i:1876;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:35101;}i:1877;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:" Variable-length strings: In such strings, a maximum length up to 32,767, for the string is specified and no padding takes place.";}i:2;i:35105;}i:1878;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:35234;}i:1879;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:35234;}i:1880;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:35234;}i:1881;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:35234;}i:1882;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:100:" Character large objects (CLOBs): These are variable-length strings that can be up to 128 terabytes.";}i:2;i:35238;}i:1883;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:35338;}i:1884;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:35338;}i:1885;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:35338;}i:1886;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35338;}i:1887;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"PL/SQL strings could be either variables or literals. A string literal is enclosed within quotation marks. For example,";}i:2;i:35340;}i:1888;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35460;}i:1889;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:44:"'This is a string literal.' Or 'hello world'";}i:2;i:35460;}i:1890;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35460;}i:1891;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:112:"To include a single quote inside a string literal, you need to type two single quotes next to one another, like:";}i:2;i:35508;}i:1892;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35621;}i:1893;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:32:"'this isn''t what it looks like'";}i:2;i:35621;}i:1894;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:35657;}i:1895;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"Declaring String Variables";i:1;i:2;i:2;i:35657;}i:2;i:35657;}i:1896;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:35657;}i:1897;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35657;}i:1898;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:219:"Oracle database provides numerous string datatypes , like, CHAR, NCHAR, VARCHAR2, NVARCHAR2, CLOB, and NCLOB. The datatypes prefixed with an 'N' are 'national character set' datatypes, that store Unicode character data.";}i:2;i:35697;}i:1899;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:35916;}i:1900;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:35916;}i:1901;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:214:"If you need to declare a variable-length string, you must provide the maximum length of that string. For example, the VARCHAR2 data type. The following example illustrates declaring and using some string variables:";}i:2;i:35918;}i:1902;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36133;}i:1903;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:387:"DECLARE
   name varchar2(20);
   company varchar2(30);
   introduction clob;
   choice char(1);
BEGIN
   name := 'John Smith';
   company := 'Infotech';
   introduction := ' Hello! I''m John Smith from Infotech.';
   choice := 'y';
   IF choice = 'y' THEN
      dbms_output.put_line(name);
      dbms_output.put_line(company);
      dbms_output.put_line(introduction);
   END IF;
END;
/
";}i:2;i:36133;}i:1904;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36133;}i:1905;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:287:"To declare a fixed-length string, use the CHAR datatype. Here you do not have to specify a maximum length for a fixed-length variable. If you leave off the length constraint, Oracle Database automatically uses a maximum length required. So following two declarations below are identical:";}i:2;i:36558;}i:1906;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36846;}i:1907;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:53:" red_flag CHAR(1) := 'Y';
 red_flag CHAR    := 'Y';  ";}i:2;i:36846;}i:1908;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:36906;}i:1909;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"PL/SQL String Functions and Operators";i:1;i:2;i:2;i:36906;}i:2;i:36906;}i:1910;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:36906;}i:1911;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36906;}i:1912;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:140:"PL/SQL offers the concatenation operator (||) for joining two strings. The following table provides the string functions provided by PL/SQL:";}i:2;i:36957;}i:1913;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37098;}i:1914;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:37098;}i:1915;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37098;}i:1916;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37098;}i:1917;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:37102;}i:1918;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:37103;}i:1919;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"(x); Returns the ";}i:2;i:37108;}i:1920;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:37125;}i:1921;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" value of the character x.";}i:2;i:37130;}i:1922;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37156;}i:1923;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37156;}i:1924;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37156;}i:1925;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37156;}i:1926;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:" CHR(x); Returns the character with the ";}i:2;i:37160;}i:1927;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:37200;}i:1928;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" value of x.";}i:2;i:37205;}i:1929;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37217;}i:1930;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37217;}i:1931;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37217;}i:1932;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37217;}i:1933;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:" CONCAT(x, y); Concatenates the strings x and y and return the appended string.";}i:2;i:37221;}i:1934;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37300;}i:1935;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37300;}i:1936;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37300;}i:1937;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37300;}i:1938;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:" INITCAP(x); Converts the initial letter of each word in x to uppercase and returns that string.";}i:2;i:37304;}i:1939;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37400;}i:1940;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37400;}i:1941;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37400;}i:1942;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37400;}i:1943;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:" INSTR(x, find_string [, start] [, occurrence]); Searches for find_string in x and returns the position at which it occurs.";}i:2;i:37404;}i:1944;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37527;}i:1945;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37527;}i:1946;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37527;}i:1947;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37527;}i:1948;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:99:" INSTRB(x); Returns the location of a string within another string, but returns the value in bytes.";}i:2;i:37531;}i:1949;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37630;}i:1950;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37630;}i:1951;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37630;}i:1952;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37630;}i:1953;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:50:" LENGTH(x); Returns the number of characters in x.";}i:2;i:37634;}i:1954;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37684;}i:1955;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37684;}i:1956;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37684;}i:1957;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37684;}i:1958;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:" LENGTHB(x); Returns the length of a character string in bytes for single byte character set.";}i:2;i:37688;}i:1959;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37781;}i:1960;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37781;}i:1961;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37781;}i:1962;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37781;}i:1963;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:" LOWER(x); Converts the letters in x to lowercase and returns that string.";}i:2;i:37785;}i:1964;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37859;}i:1965;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37859;}i:1966;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37859;}i:1967;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37859;}i:1968;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:" LPAD(x, width [, pad_string]); Pads x with spaces to left, to bring the total length of the string up to width characters.";}i:2;i:37863;}i:1969;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:37986;}i:1970;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:37986;}i:1971;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:37986;}i:1972;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:37986;}i:1973;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:" LTRIM(x [, trim_string]); Trims characters from the left of x.";}i:2;i:37990;}i:1974;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38053;}i:1975;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38053;}i:1976;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38053;}i:1977;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38053;}i:1978;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:" NANVL(x, value); Returns value if x matches the NaN special value (not a number), otherwise x is returned.";}i:2;i:38057;}i:1979;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38164;}i:1980;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38164;}i:1981;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38164;}i:1982;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38164;}i:1983;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:" NLS_INITCAP(x); Same as the INITCAP function except that it can use a different sort method as specified by NLSSORT.";}i:2;i:38168;}i:1984;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38285;}i:1985;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38285;}i:1986;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38285;}i:1987;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38285;}i:1988;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:" NLS_LOWER(x); Same as the LOWER function except that it can use a different sort method as specified by NLSSORT.";}i:2;i:38289;}i:1989;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38402;}i:1990;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38402;}i:1991;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38402;}i:1992;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38402;}i:1993;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:" NLS_UPPER(x); Same as the UPPER function except that it can use a different sort method as specified by NLSSORT.";}i:2;i:38406;}i:1994;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38519;}i:1995;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38519;}i:1996;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38519;}i:1997;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38519;}i:1998;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:143:" NLSSORT(x); Changes the method of sorting the characters. Must be specified before any NLS function; otherwise, the default sort will be used.";}i:2;i:38523;}i:1999;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38666;}i:2000;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38666;}i:2001;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38666;}i:2002;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38666;}i:2003;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" NVL(x, value); Returns value if x is null; otherwise, x is returned.";}i:2;i:38670;}i:2004;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38739;}i:2005;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38739;}i:2006;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38739;}i:2007;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38739;}i:2008;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:" NVL2(x, value1, value2); Returns value1 if x is not null; if x is null, value2 is returned.";}i:2;i:38743;}i:2009;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38835;}i:2010;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38835;}i:2011;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38835;}i:2012;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38835;}i:2013;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:" REPLACE(x, search_string, replace_string); Searches x for search_string and replaces it with replace_string.";}i:2;i:38839;}i:2014;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:38948;}i:2015;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:38948;}i:2016;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:38948;}i:2017;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:38948;}i:2018;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:" RPAD(x, width [, pad_string]); Pads x to the right.";}i:2;i:38952;}i:2019;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39004;}i:2020;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39004;}i:2021;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:39004;}i:2022;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:39004;}i:2023;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:50:" RTRIM(x [, trim_string]); Trims x from the right.";}i:2;i:39008;}i:2024;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39058;}i:2025;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39058;}i:2026;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:39058;}i:2027;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:39058;}i:2028;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:" SOUNDEX(x); Returns a string containing the phonetic representation of x.";}i:2;i:39062;}i:2029;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39136;}i:2030;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39136;}i:2031;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:39136;}i:2032;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:39136;}i:2033;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:156:" SUBSTR(x, start [, length]); Returns a substring of x that begins at the position specified by start. An optional length for the substring may be supplied.";}i:2;i:39140;}i:2034;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39296;}i:2035;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39296;}i:2036;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:39296;}i:2037;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:39296;}i:2038;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:" SUBSTRB(x); Same as SUBSTR except the parameters are expressed in bytes instead of characters for the single-byte character systems";}i:2;i:39300;}i:2039;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39432;}i:2040;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39432;}i:2041;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:39432;}i:2042;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:39432;}i:2043;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:" TRIM([trim_char FROM) x); Trims characters from the left and right of x.";}i:2;i:39436;}i:2044;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39509;}i:2045;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39509;}i:2046;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:39509;}i:2047;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:39509;}i:2048;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:" UPPER(x); Converts the letters in x to uppercase and returns that string.";}i:2;i:39513;}i:2049;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:39587;}i:2050;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:39587;}i:2051;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:39587;}i:2052;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39587;}i:2053;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:39589;}i:2054;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"Example 1";}i:2;i:39591;}i:2055;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:39600;}i:2056;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:39602;}i:2057;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39603;}i:2058;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:100:"DECLARE
   greetings varchar2(11) := 'hello world';
BEGIN
   dbms_output.put_line(UPPER(greetings));";}i:2;i:39603;}i:2059;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:42:"   dbms_output.put_line(LOWER(greetings));";}i:2;i:39713;}i:2060;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:44:"   dbms_output.put_line(INITCAP(greetings));";}i:2;i:39759;}i:2061;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:104:"   /* retrieve the first character in the string */
   dbms_output.put_line ( SUBSTR (greetings, 1, 1));";}i:2;i:39807;}i:2062;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:104:"   /* retrieve the last character in the string */
   dbms_output.put_line ( SUBSTR (greetings, -1, 1));";}i:2;i:39917;}i:2063;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:130:"   /* retrieve five characters, 
      starting from the seventh position. */
   dbms_output.put_line ( SUBSTR (greetings, 7, 5));";}i:2;i:40027;}i:2064;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:137:"   /* retrieve the remainder of the string,
      starting from the second position. */
   dbms_output.put_line ( SUBSTR (greetings, 2));";}i:2;i:40165;}i:2065;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:102:"   /* find the location of the first "e" */
   dbms_output.put_line ( INSTR (greetings, 'e'));
END;
/
";}i:2;i:40310;}i:2066;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:40425;}i:2067;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"PL/SQL - Arrays";i:1;i:1;i:2;i:40425;}i:2;i:40425;}i:2068;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:40425;}i:2069;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40425;}i:2070;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:306:"PL/SQL programming language provides a data structure called the VARRAY, which can store a fixed-size sequential collection of elements of the same type. A varray is used to store an ordered collection of data, but it is often more useful to think of an array as a collection of variables of the same type.";}i:2;i:40456;}i:2071;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40762;}i:2072;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40762;}i:2073;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"All varrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.";}i:2;i:40764;}i:2074;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40912;}i:2075;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40912;}i:2076;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:19:":nortal:varrays.jpg";i:1;s:0:"";i:2;N;i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:40914;}i:2077;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40938;}i:2078;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40938;}i:2079;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:160:"An array is a part of collection type data and it stands for variable-size arrays. We will study other collection types in a later chapter 'PL/SQL Collections'.";}i:2;i:40940;}i:2080;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41100;}i:2081;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41100;}i:2082;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:"Each element in a varray has an index associated with it. It also has a maximum size that can be changed dynamically.";}i:2;i:41102;}i:2083;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41219;}i:2084;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:41221;}i:2085;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"Creating a Varray Type";i:1;i:2;i:2;i:41221;}i:2;i:41221;}i:2086;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:41221;}i:2087;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41221;}i:2088;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:137:"A varray type is created with the CREATE TYPE statement. You must specify the maximum size and the type of elements stored in the varray.";}i:2;i:41257;}i:2089;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41394;}i:2090;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41394;}i:2091;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:"The basic syntax for creating a VRRAY type at the schema level is:";}i:2;i:41396;}i:2092;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41463;}i:2093;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:70:"CREATE OR REPLACE TYPE varray_type_name IS VARRAY(n) of <element_type>";}i:2;i:41463;}i:2094;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41463;}i:2095;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"Where,";}i:2;i:41537;}i:2096;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41544;}i:2097;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:41544;}i:2098;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:41544;}i:2099;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:41544;}i:2100;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:" varray_type_name is a valid attribute name,";}i:2;i:41548;}i:2101;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:41592;}i:2102;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:41592;}i:2103;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:41592;}i:2104;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:41592;}i:2105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:53:" n is the number of elements (maximum) in the varray,";}i:2;i:41596;}i:2106;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:41649;}i:2107;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:41649;}i:2108;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:41649;}i:2109;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:41649;}i:2110;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" element_type is the data type of the elements of the array.";}i:2;i:41653;}i:2111;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:41713;}i:2112;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:41713;}i:2113;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:41713;}i:2114;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41713;}i:2115;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:"Maximum size of a varray can be changed using the ALTER TYPE statement.";}i:2;i:41715;}i:2116;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41786;}i:2117;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41786;}i:2118;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"For example,";}i:2;i:41788;}i:2119;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41801;}i:2120;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:78:"CREATE Or REPLACE TYPE namearray AS VARRAY(3) OF VARCHAR2(10);
/
Type created.";}i:2;i:41801;}i:2121;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41801;}i:2122;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"The basic syntax for creating a VRRAY type within a PL/SQL block is:";}i:2;i:41885;}i:2123;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:41954;}i:2124;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:52:"TYPE varray_type_name IS VARRAY(n) of <element_type>";}i:2;i:41954;}i:2125;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:41954;}i:2126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"For example:";}i:2;i:42010;}i:2127;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:42023;}i:2128;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:82:"TYPE namearray IS VARRAY(5) OF VARCHAR2(10);
Type grades IS VARRAY(5) OF INTEGER;
";}i:2;i:42023;}i:2129;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:42023;}i:2130;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:42113;}i:2131;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"Example 1";}i:2;i:42115;}i:2132;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:42124;}i:2133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:"
The following program illustrates using varrays:  ";}i:2;i:42126;}i:2134;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:42177;}i:2135;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:484:"DECLARE
   type namesarray IS VARRAY(5) OF VARCHAR2(10);
   type grades IS VARRAY(5) OF INTEGER;
   names namesarray;
   marks grades;
   total integer;
BEGIN
   names := namesarray('Kavita', 'Pritam', 'Ayan', 'Rishav', 'Aziz');
   marks:= grades(98, 97, 78, 87, 92);
   total := names.count;
   dbms_output.put_line('Total '|| total || ' Students');
   FOR i in 1 .. total LOOP
      dbms_output.put_line('Student: ' || names(i) || '
      Marks: ' || marks(i));
   END LOOP;
END;
/
";}i:2;i:42177;}i:2136;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:42177;}i:2137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"Please note:";}i:2;i:42699;}i:2138;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:42712;}i:2139;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:42712;}i:2140;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:42712;}i:2141;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:42712;}i:2142;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:" In oracle environment, the starting index for varrays is always 1.";}i:2;i:42716;}i:2143;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:42783;}i:2144;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:42783;}i:2145;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:42783;}i:2146;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:42783;}i:2147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:" You can initialize the varray elements using the constructor method of the varray type, which has the same name as the varray.";}i:2;i:42787;}i:2148;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:42914;}i:2149;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:42914;}i:2150;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:42914;}i:2151;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:42914;}i:2152;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:" Varrays are one-dimensional arrays.";}i:2;i:42918;}i:2153;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:42954;}i:2154;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:42954;}i:2155;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:42954;}i:2156;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:42954;}i:2157;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:" A varray is automatically NULL when it is declared and must be initialized before its elements can be referenced.";}i:2;i:42958;}i:2158;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43072;}i:2159;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43072;}i:2160;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:43072;}i:2161;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:43074;}i:2162;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"PL/SQL - Procedures";i:1;i:1;i:2;i:43074;}i:2;i:43074;}i:2163;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:43074;}i:2164;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43074;}i:2165;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"A ";}i:2;i:43109;}i:2166;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:43111;}i:2167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"subprogram";}i:2;i:43113;}i:2168;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:43123;}i:2169;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:259:" is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design'. A subprogram can be invoked by another subprogram or program which is called the calling program.";}i:2;i:43125;}i:2170;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43384;}i:2171;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43384;}i:2172;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"A subprogram can be created:";}i:2;i:43386;}i:2173;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43415;}i:2174;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:43415;}i:2175;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43415;}i:2176;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43415;}i:2177;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" At schema level";}i:2;i:43419;}i:2178;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43435;}i:2179;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43435;}i:2180;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43435;}i:2181;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43435;}i:2182;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" Inside a package";}i:2;i:43439;}i:2183;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43456;}i:2184;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43456;}i:2185;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:43456;}i:2186;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:43456;}i:2187;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" Inside a PL/SQL block";}i:2;i:43460;}i:2188;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:43482;}i:2189;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:43482;}i:2190;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:43482;}i:2191;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43482;}i:2192;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:223:"A schema level subprogram is a standalone subprogram. It is created with the CREATE PROCEDURE or CREATE FUNCTION statement. It is stored in the database and can be deleted with the DROP PROCEDURE or DROP FUNCTION statement.";}i:2;i:43484;}i:2193;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43707;}i:2194;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43707;}i:2195;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:238:"A subprogram created inside a package is a packaged subprogram. It is stored in the database and can be deleted only when the package is deleted with the DROP PACKAGE statement. We will discuss packages in the chapter 'PL/SQL - Packages'.";}i:2;i:43709;}i:2196;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:43947;}i:2197;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43947;}i:2198;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:130:"PL/SQL subprograms are named PL/SQL blocks that can be invoked with a set of parameters. PL/SQL provides two kinds of subprograms:";}i:2;i:43949;}i:2199;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:44080;}i:2200;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:44080;}i:2201;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:44080;}i:2202;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:44080;}i:2203;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:" Functions: these subprograms return a single value, mainly used to compute and return a value.";}i:2;i:44084;}i:2204;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:44179;}i:2205;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:44179;}i:2206;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:44179;}i:2207;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:44179;}i:2208;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:" Procedures: these subprograms do not return a value directly, mainly used to perform an action.";}i:2;i:44183;}i:2209;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:44279;}i:2210;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:44279;}i:2211;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:44279;}i:2212;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:44279;}i:2213;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"This chapter is going to cover important aspects of a PL/SQL procedure and we will cover PL/SQL function in next chapter.";}i:2;i:44281;}i:2214;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:44402;}i:2215;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:44404;}i:2216;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:28:"Parts of a PL/SQL Subprogram";i:1;i:2;i:2;i:44404;}i:2;i:44404;}i:2217;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:44404;}i:2218;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:44404;}i:2219;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:168:"Each PL/SQL subprogram has a name, and may have a parameter list. Like anonymous PL/SQL blocks and, the named blocks a subprograms will also have following three parts:";}i:2;i:44446;}i:2220;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:44615;}i:2221;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:4;i:2;i:44616;}i:2;i:44615;}i:2222;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:44615;}i:2223;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:44615;}i:2224;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:44615;}i:2225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" S.N. ";}i:2;i:44617;}i:2226;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:44623;}i:2227;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:44623;}i:2228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:" Parts & Description ";}i:2;i:44624;}i:2229;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:44645;}i:2230;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:44646;}i:2231;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:44646;}i:2232;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:44646;}i:2233;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:44646;}i:2234;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 1 ";}i:2;i:44648;}i:2235;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:44651;}i:2236;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:44651;}i:2237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:44652;}i:2238;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:44653;}i:2239;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"Declarative Part";}i:2;i:44655;}i:2240;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:44671;}i:2241;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:318:" - It is an optional part. However, the declarative part for a subprogram does not start with the DECLARE keyword. It contains declarations of types, cursors, constants, variables, exceptions, and nested subprograms. These items are local to the subprogram and cease to exist when the subprogram completes execution.  ";}i:2;i:44673;}i:2242;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:44991;}i:2243;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:44992;}i:2244;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:44992;}i:2245;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:44992;}i:2246;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 2 ";}i:2;i:44994;}i:2247;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:44997;}i:2248;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:44997;}i:2249;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:44998;}i:2250;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:44999;}i:2251;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Executable Part";}i:2;i:45001;}i:2252;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:45016;}i:2253;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:" - This is a mandatory part and contains statements that perform the designated action. ";}i:2;i:45018;}i:2254;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:45106;}i:2255;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:45107;}i:2256;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:45107;}i:2257;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:45107;}i:2258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 3 ";}i:2;i:45109;}i:2259;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:45112;}i:2260;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;s:4:"left";i:2;i:1;}i:2;i:45112;}i:2261;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:45113;}i:2262;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:45114;}i:2263;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"Exception-handling";}i:2;i:45116;}i:2264;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:45134;}i:2265;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:" - This is again an optional part. It contains the code that handles run-time errors.  ";}i:2;i:45136;}i:2266;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:45223;}i:2267;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:45224;}i:2268;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:45224;}i:2;i:45224;}i:2269;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:45226;}i:2270;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Creating a Procedure";i:1;i:2;i:2;i:45226;}i:2;i:45226;}i:2271;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:45226;}i:2272;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:45226;}i:2273;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:"A procedure is created with the CREATE OR REPLACE PROCEDURE statement. The simplified syntax for the CREATE OR REPLACE PROCEDURE statement is as follows:";}i:2;i:45260;}i:2274;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:45414;}i:2275;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:154:"CREATE [OR REPLACE] PROCEDURE procedure_name
[(parameter_name [IN | OUT | IN OUT] type [, ...])]
{IS | AS}
BEGIN
  < procedure_body >
END procedure_name;
";}i:2;i:45414;}i:2276;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:45414;}i:2277;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"Where,";}i:2;i:45584;}i:2278;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:45591;}i:2279;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:45591;}i:2280;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:45591;}i:2281;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:45591;}i:2282;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:" procedure-name specifies the name of the procedure.";}i:2;i:45595;}i:2283;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:45647;}i:2284;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:45647;}i:2285;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:45647;}i:2286;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:45647;}i:2287;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" [OR REPLACE] option allows modifying an existing procedure.";}i:2;i:45651;}i:2288;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:45711;}i:2289;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:45711;}i:2290;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:45711;}i:2291;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:45711;}i:2292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:226:" The optional parameter list contains name, mode and types of the parameters. IN represents that value will be passed from outside and OUT represents that this parameter will be used to return a value outside of the procedure.";}i:2;i:45715;}i:2293;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:45941;}i:2294;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:45941;}i:2295;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:45941;}i:2296;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:45941;}i:2297;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:" procedure-body contains the executable part.";}i:2;i:45945;}i:2298;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:45990;}i:2299;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:45990;}i:2300;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:45990;}i:2301;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:45990;}i:2302;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:" The AS keyword is used instead of the IS keyword for creating a standalone procedure.  ";}i:2;i:45994;}i:2303;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:46082;}i:2304;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:46082;}i:2305;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:46082;}i:2306;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46082;}i:2307;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:46084;}i:2308;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"Example";}i:2;i:46086;}i:2309;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:46093;}i:2310;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46095;}i:2311;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46095;}i:2312;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:"The following example creates a simple procedure that displays the string 'Hello World!' on the screen when executed.";}i:2;i:46097;}i:2313;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46215;}i:2314;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:95:"CREATE OR REPLACE PROCEDURE greetings
AS
BEGIN
   dbms_output.put_line('Hello World!');
END;
/
";}i:2;i:46215;}i:2315;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:46326;}i:2316;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"Executing a Standalone Procedure";i:1;i:2;i:2;i:46326;}i:2;i:46326;}i:2317;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:46326;}i:2318;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46326;}i:2319;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:"A standalone procedure can be called in two ways:";}i:2;i:46372;}i:2320;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46422;}i:2321;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:46422;}i:2322;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:46422;}i:2323;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:46422;}i:2324;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" Using the EXECUTE keyword";}i:2;i:46426;}i:2325;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:46452;}i:2326;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:46452;}i:2327;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:46452;}i:2328;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:46452;}i:2329;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:" Calling the name of the procedure from a PL/SQL block";}i:2;i:46456;}i:2330;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:46510;}i:2331;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:46510;}i:2332;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:46510;}i:2333;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46510;}i:2334;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"The above procedure named 'greetings' can be called with the EXECUTE keyword as:";}i:2;i:46512;}i:2335;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46593;}i:2336;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:18:"EXECUTE greetings;";}i:2;i:46593;}i:2337;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46593;}i:2338;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"The above call would display:";}i:2;i:46615;}i:2339;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46645;}i:2340;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:11:"Hello World";}i:2;i:46645;}i:2341;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:40:"PL/SQL procedure successfully completed.";}i:2;i:46659;}i:2342;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46659;}i:2343;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:"The procedure can also be called from another PL/SQL block:";}i:2;i:46703;}i:2344;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46763;}i:2345;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:27:"BEGIN
   greetings;
END;
/
";}i:2;i:46763;}i:2346;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46763;}i:2347;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"The above call would display:";}i:2;i:46802;}i:2348;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:46832;}i:2349;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:11:"Hello World";}i:2;i:46832;}i:2350;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:41:"PL/SQL procedure successfully completed.
";}i:2;i:46847;}i:2351;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:46894;}i:2352;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"Deleting a Standalone Procedure";i:1;i:2;i:2;i:46894;}i:2;i:46894;}i:2353;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:46894;}i:2354;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:46894;}i:2355;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:"A standalone procedure is deleted with the DROP PROCEDURE statement. Syntax for deleting a procedure is:";}i:2;i:46939;}i:2356;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:47044;}i:2357;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:30:"DROP PROCEDURE procedure-name;";}i:2;i:47044;}i:2358;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:47044;}i:2359;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:"So you can drop greetings procedure by using the following statement:";}i:2;i:47078;}i:2360;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:47148;}i:2361;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:25:"DROP PROCEDURE greetings;";}i:2;i:47148;}i:2362;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:47177;}i:2363;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"Parameter Modes in PL/SQL Subprograms";i:1;i:2;i:2;i:47177;}i:2;i:47177;}i:2364;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:47177;}i:2365;a:3:{i:0;s:10:"table_open";i:1;a:3:{i:0;i:2;i:1;i:4;i:2;i:47228;}i:2;i:47227;}i:2366;a:3:{i:0;s:15:"tablethead_open";i:1;a:0:{}i:2;i:47227;}i:2367;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:47227;}i:2368;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:47227;}i:2369;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" S.N. ";}i:2;i:47229;}i:2370;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:47235;}i:2371;a:3:{i:0;s:16:"tableheader_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:47235;}i:2372;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:" Parameter Mode & Description ";}i:2;i:47236;}i:2373;a:3:{i:0;s:17:"tableheader_close";i:1;a:0:{}i:2;i:47266;}i:2374;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:47267;}i:2375;a:3:{i:0;s:16:"tablethead_close";i:1;a:0:{}i:2;i:47267;}i:2376;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:47267;}i:2377;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:47267;}i:2378;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 1 ";}i:2;i:47269;}i:2379;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:47272;}i:2380;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:47272;}i:2381;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:47273;}i:2382;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:47274;}i:2383;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"IN";}i:2;i:47276;}i:2384;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:47278;}i:2385;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:462:" - An IN parameter lets you pass a value to the subprogram. It is a read-only parameter. Inside the subprogram, an IN parameter acts like a constant. It cannot be assigned a value. You can pass a constant, literal, initialized variable, or expression as an IN parameter. You can also initialize it to a default value; however, in that case, it is omitted from the subprogram call. It is the default mode of parameter passing. Parameters are passed by reference. ";}i:2;i:47280;}i:2386;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:47742;}i:2387;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:47743;}i:2388;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:47743;}i:2389;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:47743;}i:2390;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 2 ";}i:2;i:47745;}i:2391;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:47748;}i:2392;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:47748;}i:2393;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:47749;}i:2394;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:47750;}i:2395;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"OUT";}i:2;i:47752;}i:2396;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:47755;}i:2397;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:256:" - An OUT parameter returns a value to the calling program. Inside the subprogram, an OUT parameter acts like a variable. You can change its value and reference the value after assigning it. The actual parameter must be variable and it is passed by value. ";}i:2;i:47757;}i:2398;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:48013;}i:2399;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:48014;}i:2400;a:3:{i:0;s:13:"tablerow_open";i:1;a:0:{}i:2;i:48014;}i:2401;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:48014;}i:2402;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" 3 ";}i:2;i:48016;}i:2403;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:48019;}i:2404;a:3:{i:0;s:14:"tablecell_open";i:1;a:3:{i:0;i:1;i:1;N;i:2;i:1;}i:2;i:48019;}i:2405;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:48020;}i:2406;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:48021;}i:2407;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"IN OUT";}i:2;i:48023;}i:2408;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:48029;}i:2409;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:359:" - An IN OUT parameter passes an initial value to a subprogram and returns an updated value to the caller. It can be assigned a value and its value can be read. The actual parameter corresponding to an IN OUT formal parameter must be a variable, not a constant or an expression. Formal parameter must be assigned a value. Actual parameter is passed by value. ";}i:2;i:48031;}i:2410;a:3:{i:0;s:15:"tablecell_close";i:1;a:0:{}i:2;i:48390;}i:2411;a:3:{i:0;s:14:"tablerow_close";i:1;a:0:{}i:2;i:48391;}i:2412;a:3:{i:0;s:11:"table_close";i:1;a:1:{i:0;i:48391;}i:2;i:48391;}i:2413;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:48391;}i:2414;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:48393;}i:2415;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"IN & OUT Mode Example 1";}i:2;i:48395;}i:2416;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:48418;}i:2417;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:48420;}i:2418;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:48420;}i:2419;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:140:"This program finds the minimum of two values, here procedure takes two numbers using IN mode and returns their minimum using OUT parameters.";}i:2;i:48422;}i:2420;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:48563;}i:2421;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:46:"DECLARE
   a number;
   b number;
   c number;";}i:2;i:48563;}i:2422;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:134:"PROCEDURE findMin(x IN number, y IN number, z OUT number) IS
BEGIN
   IF x < y THEN
      z:= x;
   ELSE
      z:= y;
   END IF;
END; ";}i:2;i:48619;}i:2423;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:112:"BEGIN
   a:= 23;
   b:= 45;
   findMin(a, b, c);
   dbms_output.put_line(' Minimum of (23, 45) : ' || c);
END;
/";}i:2;i:48771;}i:2424;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:48771;}i:2425;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"When the above code is executed at SQL prompt, it produces the following result:";}i:2;i:48900;}i:2426;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:48981;}i:2427;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:25:" Minimum of (23, 45) : 23";}i:2;i:48981;}i:2428;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:41:"PL/SQL procedure successfully completed.
";}i:2;i:49010;}i:2429;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:49057;}i:2430;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"Methods for Passing Parameters";i:1;i:2;i:2;i:49057;}i:2;i:49057;}i:2431;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:49057;}i:2432;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49057;}i:2433;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"Actual parameters could be passed in three ways:";}i:2;i:49101;}i:2434;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:49150;}i:2435;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:49150;}i:2436;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:49150;}i:2437;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:49150;}i:2438;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" Positional notation";}i:2;i:49154;}i:2439;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:49174;}i:2440;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:49174;}i:2441;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:49174;}i:2442;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:49174;}i:2443;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" Named notation";}i:2;i:49178;}i:2444;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:49193;}i:2445;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:49193;}i:2446;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:49193;}i:2447;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:49193;}i:2448;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:" Mixed notation";}i:2;i:49197;}i:2449;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:49212;}i:2450;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:49212;}i:2451;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:49212;}i:2452;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:49214;}i:2453;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"POSITIONAL NOTATION";i:1;i:3;i:2;i:49214;}i:2;i:49214;}i:2454;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:49214;}i:2455;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49214;}i:2456;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:"In positional notation, you can call the procedure as:";}i:2;i:49245;}i:2457;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:49299;}i:2458;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:20:"findMin(a, b, c, d);";}i:2;i:49299;}i:2459;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49299;}i:2460;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:287:"In positional notation, the first actual parameter is substituted for the first formal parameter; the second actual parameter is substituted for the second formal parameter, and so on. So, a is substituted for x, b is substituted for y, c is substituted for z and d is substituted for m.";}i:2;i:49322;}i:2461;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:49609;}i:2462;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:49611;}i:2463;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"NAMED NOTATION";i:1;i:3;i:2;i:49611;}i:2;i:49611;}i:2464;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:49611;}i:2465;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49611;}i:2466;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:105:"In named notation, the actual parameter is associated with the formal parameter using the arrow symbol ( ";}i:2;i:49637;}i:2467;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"=>";}i:2;i:49742;}i:2468;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:" ). So the procedure call would look like:";}i:2;i:49744;}i:2469;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:49786;}i:2470;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:33:"findMin(x=>a, y=>b, z=>c, m=>d);
";}i:2;i:49786;}i:2471;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:49825;}i:2472;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"MIXED NOTATION";i:1;i:3;i:2;i:49825;}i:2;i:49825;}i:2473;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:49825;}i:2474;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49825;}i:2475;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:"In mixed notation, you can mix both notations in procedure call; however, the positional notation should precede the named notation.";}i:2;i:49851;}i:2476;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:49983;}i:2477;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:49983;}i:2478;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"The following call is legal:";}i:2;i:49985;}i:2479;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:50013;}i:2480;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:23:"findMin(a, b, c, m=>d);";}i:2;i:50013;}i:2481;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:50013;}i:2482;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"But this is not legal:";}i:2;i:50040;}i:2483;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:50062;}i:2484;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:25:"findMin(x=>a, b, c, d);  ";}i:2;i:50062;}i:2485;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:50091;}i:2486;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:50091;}}